#pragma GCC optimize ("O0") // optimize on demand

/**
 * Source is based on ancient code and insights.
 * Code changes should be kept to an absolute minimum.
 * Don't be tempted...
 */

/**
 * `eval` is the reference implementation of the basic concepts of this project
 * and is therefore the authoritative outcome in cases of dispute during regression testing.
 *
 * Hardcoded for 9 endpoints (a-i) and 128 nodes.
 *
 * It demonstrates:
 *   - The parsing of postfix notations
 *   - Constructing Level-1 normalised trees
 *   - Evaluating
 *   - Composing postfix notations
 *
 * @date 2020-03-06 16:56:25
 */

/*
 *	This file is part of Untangle, Information in fractal structures.
 *	Copyright (C) 2017-2020, xyzzy@rockingship.org
 *
 *	This program is free software: you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation, either version 3 of the License, or
 *	(at your option) any later version.
 *
 *	This program is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#if 0
/**
 * Reference implementation on how to use the output generated by `"--code"`
 *
 * The first array entry is reserved for the reference value `null/zero/false`
 * The next 9 entries are the input endpoints
 * The remainder entries are the QTF nodes
 *
 * @date 2020-03-06 17:59:31
 */

#include <stdio.h>

int main() {
    for (unsigned a=0; a<2; a++)
    for (unsigned b=0; b<2; b++)
    for (unsigned c=0; c<2; c++)
    for (unsigned d=0; d<2; d++)
    for (unsigned e=0; e<2; e++)
    for (unsigned f=0; f<2; f++)
    for (unsigned g=0; g<2; g++)
    for (unsigned h=0; h<2; h++)
    for (unsigned i=0; i<2; i++) {

	int bit = ({ unsigned _[] = {0,a,b,c,d,e,f,g,h,i,_[1]?_[2]:!_[3],};!_[10];});

	printf("%d", bit);
    }
    printf("%d\n");

    return 0;
}
#endif

#include <stdint.h>
#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <string.h>
#include <getopt.h>

/**
 * Constants
 */

#define MAXSLOTS 9               /** @constant {number} MAXSLOTS - Maximum number of slots/variables for the evaluator */
#define IBIT 0x80000000          /** @constant {number} IBIT - Which bit of the operand is reserved to flag that the result needs to be inverted */
#define NUMNODES 999             /** @constant {number} NUMNODES - Maximum number of nodes the tree can contain */
#define KSTART 1                 /** @constant {number} KSTART - Starting index in tree where to find the input endpoints. */
#define SBUFMAX (10 * NUMNODES)  /** @constant {number} SBUFMAX - Maximum size of constructed notation. Roughly assuming 3 characters per operand and operator */
//#define NSTART (KSTART+MAXSLOTS) /** @constant {number} NSTART - Starting index in tree for QTF nodes. The evaluator starts from this position */
#define QUADPERFOOTPRINT ((1 << MAXSLOTS) / 64) /** @constant {number} QUADPERFOOTPRINT - Size of footprint in terms of uint64_t */

/**
 * User specified program options
 */

unsigned opt_quiet = 0;     /** @global {number} opt_quiet - --quiet */
unsigned opt_verbose = 0;   /** @global {number} opt_verbose - --verbose */
unsigned opt_normalise = 0; /** @global {number} opt_normalise - --normalise, display notation as normalised endpoints with explicit permutation mapping */
unsigned opt_code = 0;      /** @global {number} opt_code - --code, output tree as gcc statement expression */
unsigned opt_fast = 0;      /** @global {number} opt_fast - --fast, do not unnormalised input */
unsigned opt_qntf = 0;      /** @global {number} opt_qntf - --qntf, output exclusively as QnTF */
unsigned opt_seed = 0;      /** @global {number} opt_seed - --seed=n, Random seed to generate evaluator test pattern */
unsigned opt_Q = 0;         /** @global {number} opt_Q - --Q, Select the `"question"` part of the top-level node */
unsigned opt_T = 0;         /** @global {number} opt_T - --T, Select the `"when-true"` part of the top-level node */
unsigned opt_F = 0;         /** @global {number} opt_F - --F, Select the `"when-false"` part of the top-level node */

/**
 * Program usage. Keep high in source code for easy reference
 *
 * @param {string[]} argv - program arguments
 * @param {boolean} verbose - set to true for option descriptions
 * @date  2020-03-06 21:06:01
 */
void usage(char *const *argv, bool verbose) {
	fprintf(stderr, "usage: %s <pattern> ...\n", argv[0]);
	if (verbose) {
		fprintf(stderr, "\t-q --quiet\n");
		fprintf(stderr, "\t-v --verbose\n");
		fprintf(stderr, "\t-n --normalise  Display notation as normalised endpoints with permutation mapping\n");
		fprintf(stderr, "\t-C --code       Output tree as gcc statement expression\n");
		fprintf(stderr, "\t-f --fast       Do not normalise input\n");
		fprintf(stderr, "\t-r --qntf       Output exclusively as QnTF\n");
		fprintf(stderr, "\t   --seed=n     Random seed to generate evaluator test pattern. [Default=%d]\n", opt_seed);
		fprintf(stderr, "\t-Q              Select top-level Q\n");
		fprintf(stderr, "\t-T              Select top-level T\n");
		fprintf(stderr, "\t-F              Select top-level F\n");
	}
}

/**
 * struct representing a 512 bit vector, each bit representing the outcome of the unified operator for every possible state 9 variables can take
 * The vector is split into a collection of 64bit wide words.
 *
 * As this is a reference implementation, `SIMD` instructions should be avoided.
 *
 * @date 2020-03-06 23:23:32
 */
struct footprint_t {
	uint64_t bits[QUADPERFOOTPRINT]; // = 512/64 = 8 = QUADPERFOOTPRINT
};

/**
 * Language structure representing the unified operator
 *
 * @date 2020-03-06 21:14:47
 */
struct node_t {
	uint32_t Q; /** @property {number} - tree index to `"question"` */
	uint32_t T; /** @property {number} - tree index to `"when-true"` */
	uint32_t F; /** @property {number} - tree index to `"when-false"` */
};

/**
 * Language structure representing the fractal tree
 *
 * @date 2020-03-06 21:45:08
 */
struct tree_t {

	uint32_t kstart; /** @property {number} - index of first endpoint */
	uint32_t nstart; /** @property {number} - index of first node */
	uint32_t count;  /** @property {number} - first free index */

	node_t N[NUMNODES];  /** @property {object[]} - array of unified operators */
	uint32_t root;   /** @property {number} - entrypoint/index where the result can be found */

	/**
	 * Constructor
	 *
	 * @param {number} kstart - index of first endpoint
 	 * @param {number} kstart - nstart of first node
	 * @param {number} nend - size of tree (depreciated)
 	 * @date 2020-03-06 21:46:08
	 */

	inline tree_t(uint32_t kstart, uint32_t nstart, uint32_t nend)
		: kstart(kstart), nstart(nstart), count(nstart) {
	}

	/**
	 * Copy constructor
	 *
	 * @param {object} rhs - right hans side of assignment
	 * @return {object} deep copy of object
	 * @date 2020-03-06 22:30:00
	 */
	inline tree_t(const tree_t &rhs) {
		assert(!"copy constructor not supported");
	}

	/**
	 * Assignment operator
	 *
	 * @param {object} rhs - right hans side of assignment
	 * @return {object} deep copy of object
	 * @date 2020-03-06 21:47:08
	 */
	inline tree_t &operator=(const tree_t &rhs) {
		assert(!"assignment constructor not supported");

		// first members
		this->kstart = rhs.kstart;
		this->nstart = rhs.nstart;
		this->count = rhs.count;

		// then nodes
		for (uint32_t i = rhs.nstart; i < count; i++)
			this->N[i] = rhs.N[i];

		// roots last
		this->root = rhs.root;

		return *this;
	}

	/**
	 * Erase the contents
	 *
	 * @date 2020-03-06 22:27:36
	 */
	inline void clear(void) {
		this->count = this->nstart; // rewind first free node
		this->root = 0; // set result to zero-reference
	}

	/**
	 * Parse notation and construct tree accordingly.
	 * Notation is assumed to be normalised.
	 *
	 * Do not spend too much effort on detailing errors
	 *
	 * @param {string} pPattern - The notation describing the tree
	 * @param {string} pTransform - Optional input endpoint permutation mapping.
	 * @return non-zero when parsing failed
	 * @date 2020-03-07 00:12:44
	 */
	int decodeFast(const char *pPattern, const char *pTransform = "abcdefghi") {
		// initialise tree
		this->count = this->nstart;
		this->root = 0;

		// temporary stack storage for postfix notation
		uint32_t stack[NUMNODES];
		int stackpos = 0;
		uint32_t prefix = 0;

		// walk through the string until end or until pattern/transform separator
		for (const char *pattern = pPattern; *pattern != 0 && *pattern != '/'; pattern++) {

			// skip spaces
			if (isspace(*pattern))
				continue;

			// test for prefix
			if (isupper(*pattern)) {
				prefix = prefix * 26 + *pattern - 'A';
				continue;
			}

			// test for endpoint
			if (islower(*pattern)) {
				uint32_t nid; // node id

				// determine final value
				nid = this->kstart + prefix * 26 + *pattern - 'a';

				// reset prefix
				prefix = 0;

				// range check
				if (nid >= this->nstart) {
					printf("[endpoint out-of-range: %d]\n", nid);
					return 1;
				}

				if (stackpos >= NUMNODES) {
					printf("[stack overflow]\n");
					return 1;
				}

				// Push the index of the endpoint onto the stack
				stack[stackpos++] = nid;
				continue;
			}

			// test for backreference
			// loading is non-normalised and each opcode symbol populates exactly one node making calculations fairly easy
			if (isdigit(*pattern)) {
				uint32_t nid; // node id

				// determine final value
				nid = prefix * 10 + *pattern - '0';

				// reset prefix
				prefix = 0;

				// range check
				if (stackpos >= NUMNODES) {
					printf("[stack overflow]\n");
					return 1;
				}

				// special case: '0' is actually zero
				if (nid == 0) {
					stack[stackpos++] = 0;
					continue;
				}

				// convert relative to absolute index
				nid = this->count - nid;

				// rangecheck
				if (nid < this->nstart || nid >= this->count) {
					printf("[back reference out-of-range]\n");
					return 1;
				}

				// Push the index of the back reference onto the stack
				stack[stackpos++] = nid;
				continue;
			}

			// prefix must be zero
			if (prefix) {
				printf("[non-zero prefix]\n");
				return 1;
			}

			// test if new operator will fit
			if (this->count >= NUMNODES) {
				printf("[too large]\n");
				return 1;
			}

			switch (*pattern) {
				case '>': {
					// GT (appreciated)
					if (stackpos < 2) {
						printf("[stack underflow]\n");
						return 1;
					}

					//pop operands
					uint32_t R = stack[--stackpos]; // right hand side
					uint32_t L = stack[--stackpos]; // left hand side

					if ((L & IBIT) || (R & IBIT)) {
						printf("[invert not normalised]\n");
						return 1;
					}
					if (L >= this->count || R >= this->count) {
						printf("[operand out-of-range]\n");
						return 1;
					}

					// create operator
					this->N[this->count].Q = L;
					this->N[this->count].T = R ^ IBIT;
					this->N[this->count].F = 0;

					// push
					stack[stackpos++] = this->count++;
					break;
				}

				case '^': {
					// XOR (appreciated)
					if (stackpos < 2) {
						printf("[stack underflow]\n");
						return 1;
					}

					//pop operands
					uint32_t R = stack[--stackpos]; // right hand side
					uint32_t L = stack[--stackpos]; // left hand side

					if ((L & IBIT) || (R & IBIT)) {
						printf("[invert not normalised]\n");
						return 1;
					}
					if (L >= this->count || R >= this->count) {
						printf("[operand out-of-range]\n");
						return 1;
					}

					// create operator
					this->N[this->count].Q = L;
					this->N[this->count].T = R ^ IBIT;
					this->N[this->count].F = R;

					// push
					stack[stackpos++] = this->count++;
					break;
				}

				case '+': {
					// OR (appreciated)
					if (stackpos < 2) {
						printf("[stack underflow]\n");
						return 1;
					}

					// pop operands
					uint32_t R = stack[--stackpos]; // right hand side
					uint32_t L = stack[--stackpos]; // left hand side

					if ((L & IBIT) || (R & IBIT)) {
						printf("[invert not normalised]\n");
						return 1;
					}
					if (L >= this->count || R >= this->count) {
						printf("[operand out-of-range]\n");
						return 1;
					}

					// create operator
					this->N[this->count].Q = L;
					this->N[this->count].T = 0 ^ IBIT;
					this->N[this->count].F = R;

					// push
					stack[stackpos++] = this->count++;
					break;
				}

				case '!': {
					// QnTF (appreciated)
					if (stackpos < 3) {
						printf("[stack underflow]\n");
						return 1;
					}

					// pop operands
					uint32_t F = stack[--stackpos];
					uint32_t T = stack[--stackpos];
					uint32_t Q = stack[--stackpos];

					if ((Q & IBIT) || (T & IBIT) || (F & IBIT)) {
						printf("[invert not normalised]\n");
						return 1;
					}
					if (Q >= this->count || T >= this->count || F >= this->count) {
						printf("[operand out-of-range]\n");
						return 1;
					}

					// create operator
					this->N[this->count].Q = Q;
					this->N[this->count].T = T ^ IBIT;
					this->N[this->count].F = F;

					// push
					stack[stackpos++] = this->count++;
					break;
				}

				case '&': {
					// AND (depreciated)
					if (stackpos < 2) {
						printf("[stack underflow]\n");
						return 1;
					}

					// pop operands
					uint32_t R = stack[--stackpos]; // right hand side
					uint32_t L = stack[--stackpos]; // left hand side

					if ((L & IBIT) || (R & IBIT)) {
						printf("[invert not normalised]\n");
						return 1;
					}
					if (L >= this->count || R >= this->count) {
						printf("[operand out-of-range]\n");
						return 1;
					}

					// create operator
					this->N[this->count].Q = L;
					this->N[this->count].T = R;
					this->N[this->count].F = 0;

					// push
					stack[stackpos++] = this->count++;
					break;
				}

				case '?': {
					// QTF (depreciated)
					if (stackpos < 3) {
						printf("[stack underflow]\n");
						return 1;
					}

					// pop operands
					uint32_t F = stack[--stackpos];
					uint32_t T = stack[--stackpos];
					uint32_t Q = stack[--stackpos];

					if ((Q & IBIT) || (T & IBIT) || (F & IBIT)) {
						printf("[invert not normalised]\n");
						return 1;
					}
					if (Q >= this->count || T >= this->count || F >= this->count) {
						printf("[operand out-of-range]\n");
						return 1;
					}

					this->N[this->count].Q = Q;
					this->N[this->count].T = T;
					this->N[this->count].F = F;

					// push
					stack[stackpos++] = this->count++;
					break;
				}

				case '~': {
					// NOT (support)
					if (stackpos < 1) {
						printf("[stack underflow]\n");
						return 1;
					}

					// invert top-of-stack
					stack[stackpos - 1] ^= IBIT;

					break;
				}

				case '<': {
					// LT (support)
					if (stackpos < 2) {
						printf("[stack underflow]\n");
						return 1;
					}

					//pop operands
					uint32_t R = stack[--stackpos]; // right hand side
					uint32_t L = stack[--stackpos]; // left hand side

					if ((L & IBIT) || (R & IBIT)) {
						printf("[invert not normalised]\n");
						return 1;
					}
					if (L >= this->count || R >= this->count) {
						printf("[operand out-of-range]\n");
						return 1;
					}

					// create operator
					this->N[this->count].Q = L;
					this->N[this->count].T = 0;
					this->N[this->count].F = R;

					// push
					stack[stackpos++] = this->count++;
					break;
				}

				default:
					printf("[bad token: %c]\n", *pattern);
					return 1;
			}
		}

		if (stackpos != 1) {
			printf("[unbalanced]\n");
			return 1;
		}

		// store result into root
		this->root = stack[stackpos - 1];
		return 0;
	}

	/**
	 * Parse and given notation and create a tree accordingly
	 *
	 * This is a generic function.
	 * The actual implementation is determined by the program option `opt_fast`
	 *
	 * @param {string} pPattern - The notation describing the tree
	 * @param {string} pTransform - Optional input endpoint permutation mapping.
	 * @return non-zero when parsing failed
	 * @date
	 */
//	int decode(const char *pPattern, const char *pTransform = "abcdefghi") {
//		if (opt_fast)
//			return loadStringFast(pPattern, pTransform);
//		else
//			return loadStringSlow(pPattern, pTransform);
//	}

	/**
	 * Composing the tree notation requires state information
	 *
	 * @date 2020-03-07 15:31:50
         */
	uint8_t nextPlaceholder;            /** @var {number} nextSlot - First free placeholder */
	uint8_t nextNode;                   /** @var {number} nextLink - First free node */
	char sbuf[SBUFMAX];                 /** @var {string} sbuf - Storage for notation */
	unsigned spos;                      /** @var {number} spos - length of notation */
	uint32_t beenThere[NUMNODES];       /** @var {number[]} beenThere - for endpoints the placeholder/transform index, for nodes the nodeId of already emitted notations */
	uint32_t beenPlaceholder[NUMNODES]; /** @var {number[]} beenMap - the actual nodeId indexed by endpoint placeholder */

	/**
	 * Encode the tree index of a given node in "base/transform" notation.
	 * for endpoints (id < nstart) emit base endpoint as index to `pTransform` containing actual endpoint
	 * for nodes (id >= nstart) emit back reference reflecting the relative distance
	 *
	 * Optionally prefix endpoint/node with base26 prefix consisting of capital letters
	 *
	 * NOTE: uses recursion which might break on extremely large trees, which is not expected for this program.
	 *
	 * @param {number} id - index of node to encode
	 * @date 2020-03-08 22:26:23
	 */
	void encodeTransformOperand(uint32_t id) {

		if (id < KSTART) {
			// all operands must be >= KSTART
			assert(0);

		} else if (id < this->nstart) {

			// On first encounter assign new placeholder
			if (beenThere[id] == 0) {
				// save nodeId in transform
				beenPlaceholder[nextPlaceholder] = id;
				// save transform index as endpoint placeholder
				beenThere[id] = nextPlaceholder++;
			}

			// endpoints are notated as a lowercase letter (`'a'` resembling KSTART) base26 prefixed by uppercase letters
			char prefixStack[16];
			int prefixStackPos = 0;

			// zero-based copy of placeholder
			uint32_t v = beenThere[id] - KSTART;

			// base26 encode endpoint
			prefixStack[prefixStackPos++] = (char) ('a' + (v % 26));
			v /= 26;
			// base26 encode prefix
			while (v) {
				prefixStack[prefixStackPos++] = (char) ('A' + (v % 26));
				v /= 26;
			}
			
			// test if fits
			assert(spos + prefixStackPos + 1 < SBUFMAX - 1);

			// add to notation
			while (prefixStackPos)
				sbuf[spos++] = prefixStack[--prefixStackPos];

		} else if (beenThere[id] != 0) {
			
			// already been there. Calculate the back-reference
			uint32_t v = nextNode - beenThere[id];

			// back-references are notated as a non-zero digit base26 prefixed by uppercase letters
			char prefixStack[16];
			int prefixStackPos = 0;

			// base10 encode back-reference
			prefixStack[prefixStackPos++] = (char) ('0' + (v % 10));
			v /= 10;
			// base26 encode prefix
			while (v) {
				prefixStack[prefixStackPos++] = (char) ('A' + (v % 26));
				v /= 26;
			}

			// test if fits
			assert(spos + prefixStackPos + 1 < SBUFMAX - 1);

			// add to notation
			while (prefixStackPos)
				sbuf[spos++] = prefixStack[--prefixStackPos];

		} else {

			// call recursive encode for node
			encodeTransformQTF(id);

		}
	}

	/**
	 * Compose the notation of a given node in "base/transform" notation.
	 *
	 * @param {number} id - index of node to encode
	 * @date 2020-03-08 20:52:41
	 */
	void encodeTransformQTF(uint32_t id) {

		// extract all parts of the node
		uint32_t T  = this->N[id].T;
		uint32_t Ti = T & IBIT; // non-zero if result of `T` should be inverted
		uint32_t Tu = T & ~IBIT; // index to `T` operand
		uint32_t Q  = this->N[id].Q;
		uint32_t F  = this->N[id].F;

		// assert node is invert normalised
		assert((~Q & IBIT) && (~F & IBIT));

		// decode
		if (T == 0 && F != 0) {
			// LT `"L?0:R"`
			encodeTransformOperand(Q);
			encodeTransformOperand(F);
			assert(spos < SBUFMAX-1);
			sbuf[spos++] = '<';
		} else 	if (T == IBIT && F != 0) {
			// OR `"L?~0:R"`
			encodeTransformOperand(Q);
			encodeTransformOperand(F);
			assert(spos < SBUFMAX-1);
			sbuf[spos++] = '+';
		} else 	if (!Ti && Tu != 0 && F == 0) {
			// AND `"L?R:0"`
			encodeTransformOperand(Q);
			encodeTransformOperand(Tu);
			assert(spos < SBUFMAX-1);
			sbuf[spos++] = '&';
		} else 	if (Ti && Tu != 0 && F == 0) {
			// GT `"L?~R:0"`
			encodeTransformOperand(Q);
			encodeTransformOperand(Tu);
			assert(spos < SBUFMAX-1);
			sbuf[spos++] = '+';
		} else 	if (Ti && Tu != 0 && Tu == F) {
			// XOR `"L?~R:R"`
			encodeTransformOperand(Q);
			encodeTransformOperand(F);
			assert(spos < SBUFMAX-1);
			sbuf[spos++] = '^';
		} else 	if (Ti) {
			// QnTF `"Q?~T:F"`
			encodeTransformOperand(Q);
			encodeTransformOperand(T);
			encodeTransformOperand(F);
			assert(spos < SBUFMAX-1);
			sbuf[spos++] = '!';
		} else {
			// QnTF `"Q?T:F"`
			encodeTransformOperand(Q);
			encodeTransformOperand(T);
			encodeTransformOperand(F);
			assert(spos < SBUFMAX-1);
			sbuf[spos++] = '?';
		}

		// mark been there
		beenThere[id] = nextNode++;
	}

	/**
	 * Encode a notation describing the tree in "placeholders/transform" notation.
	 * Within the placeholders, endpoints are assigned in order of natural path which can be used as index for the transform to determine the actual endpoint.
	 *
	 * @param {number} id - entrypoint
	 * @param {character[]} pTransform - output map of endpoint placeholders to actual endpoints.
	 * @param {number} transformSize - maximum size of pTransform including string terminator
	 * @return {string} - Constructed notation. State information so no multiple calls with `printf()`.
	 * @date
	 */
	const char *encodeTransform(uint32_t id) {

		// special case
		if (id == 0) {
			sbuf[0] = '0';
			sbuf[1] = 0;
			return sbuf;
		}
		if (id == IBIT) {
			sbuf[0] = '0';
			sbuf[1] = '~';
			sbuf[2] = 0;
			return sbuf;
		}

		// setup state
		nextPlaceholder = KSTART;
		nextNode = this->nstart;
		spos = 0;
		memset(beenThere, 0, sizeof(beenThere[0]) * this->count);
		memset(beenPlaceholder, 0, sizeof(beenPlaceholder[0]) * this->nstart);

		// encode notation with placeholders
		if ((id & ~IBIT) < this->nstart) {
			// encode endpoint
			encodeTransformOperand(id & ~IBIT);
		} else {
			// encode node
			encodeTransformQTF(id & ~IBIT);

		}

		// optionally append final invert
		if (id & IBIT) {
			assert(spos < SBUFMAX - 1);
			sbuf[spos++] = '~';
		}

		// append delimiter
		assert(spos < SBUFMAX - 1);
		sbuf[spos++] = '/';

		// append contents of placeholders
		for (uint32_t ph = KSTART; ph < nextPlaceholder; ph++) {

			// endpoints are notated as a lowercase letter (`'a'` resembling KSTART) base26 prefixed by uppercase letters
			char prefixStack[16];
			int prefixStackPos = 0;

			// zero-based copy of placeholder
			uint32_t v = beenPlaceholder[ph] - KSTART;

			// base26 encode endpoint
			prefixStack[prefixStackPos++] = (char) ('a' + (v % 26));
			v /= 26;
			// base26 encode prefix
			while (v) {
				prefixStack[prefixStackPos++] = (char) ('A' + (v % 26));
				v /= 26;
			}

			// test if fits
			assert(spos + prefixStackPos + 1 < SBUFMAX - 1);

			// add to notation
			while (prefixStackPos)
				sbuf[spos++] = prefixStack[--prefixStackPos];
		}
		// append string terminator
		sbuf[spos++] = 0;

		// return encoded string
		return sbuf;
	}

	/**
         * Evaluate the tree and store the result in v[]
         *
         * `this->N` contains the unified operators.
         * The parameter of this function `v` is the runtime data to which the operators should be applied.
         *
         * For each entry of `this->N[i]` and `v[i]`:
         * - the unified operator loads the operand data from `v` indicated by `Q`, `T` and `F`
         * - functionality is applied
         * - the result is stored int `v` indexed by the location of the operator
         *
         * Each data entry is a 512-bit wide vector, split into uint64_t chunks.
         * As this is a reference implementation, `SIMD` instructions should be avoided.
         *
	 * @param {vector[]} v - the evaluated result of the unified operators
	 * @date
	 */
	inline void eval(footprint_t *v) const {
		// for all operators eligible for evaluation...
		for (unsigned i = nstart; i < this->count; i++) {
			// point to the first chunk of the `"question"`
			const uint64_t *Q = v[this->N[i].Q].bits;
			// point to the first chunk of the `"when-true"`
			// NOTE: this can be marked as "value needs be runtime inverted"
			const uint64_t *T = v[this->N[i].T & ~IBIT].bits;
			// point to the first chunk of the `"when-false"`
			const uint64_t *F = v[this->N[i].F].bits;
			// point to the first chunk of the `"result"`
			uint64_t *R = v[i].bits;

			// determine if the operator is `QTF` or `QnTF`
			if (this->N[i].T & IBIT) {
				// `QnTF` for each bit in the chunk, apply the operator `"Q ? !T : F"`
				for (unsigned j = 0; j < QUADPERFOOTPRINT; j++)
					R[j] = (Q[j] & ~T[j]) ^ (~Q[j] & F[j]);
			} else {
				// `QnTF` for each bit in the chunk, apply the operator `"Q ? T : F"`
				for (unsigned j = 0; j < QUADPERFOOTPRINT; j++)
					R[j] = (Q[j] & T[j]) ^ (~Q[j] & F[j]);
			}
		}
	}


};

/**
 * Program main entry point
 *
 * @param  {number} argc - number of arguments
 * @param  {string[]} argv - program arguments
 * @return 0 on normal return, non-zero when attention is required
 * @date   2020-03-06 20:22:23
 */
int main(int argc, char *const *argv) {
	setlinebuf(stdout);

	/*
	 *  Process program options
	 */
	for (;;) {
		// Long option shortcuts
		enum {
			// short opts
			LO_SEED = 1,
			// long opts
			LO_HELP = 'h',
			LO_QUIET = 'q',
			LO_VERBOSE = 'v',
			LO_NORMALISE = 'n',
			LO_CODE = 'C',
			LO_FAST = 'f',
			LO_QNTF = 'r',
			LO_Q = 'Q',
			LO_T = 'T',
			LO_F = 'F',
		};

		// long option descriptions
		static struct option long_options[] = {
			/* name, has_arg, flag, val */
			{"help",      0, 0, LO_HELP},
			{"quiet",     0, 0, LO_QUIET},
			{"verbose",   0, 0, LO_VERBOSE},
			{"normalise", 0, 0, LO_NORMALISE},
			{"code",      0, 0, LO_CODE},
			{"fast",      0, 0, LO_FAST},
			{"qntf",      0, 0, LO_QNTF},
			{"seed",      1, 0, LO_SEED},
			{"Q",         0, 0, LO_Q},
			{"T",         0, 0, LO_T},
			{"F",         0, 0, LO_F},

			{NULL,        0, 0, 0}
		};

		char optstring[128], *cp;
		cp = optstring;

		/* construct optarg */
		for (int i = 0; long_options[i].name; i++) {
			if (isalpha(long_options[i].val)) {
				*cp++ = (char) long_options[i].val;

				if (long_options[i].has_arg != 0)
					*cp++ = ':';
				if (long_options[i].has_arg == 2)
					*cp++ = ':';
			}
		}
		*cp = '\0';

		// parse long options
		int option_index = 0;
		int c = getopt_long(argc, argv, optstring, long_options, &option_index);
		if (c == -1)
			break;

		switch (c) {
			case LO_HELP:
				usage(argv, true);
				exit(0);
			case LO_QUIET:
				opt_quiet++;
				break;
			case LO_VERBOSE:
				opt_verbose++;
				break;
			case LO_NORMALISE:
				opt_normalise++;
				break;
			case LO_CODE:
				opt_code++;
				break;
			case LO_FAST:
				opt_fast++;
				break;
			case LO_QNTF:
				opt_qntf++;
				break;
			case LO_SEED:
				opt_seed = strtoul(optarg, NULL, 10);
				break;

			case LO_Q:
				opt_Q++;
				break;
			case LO_T:
				opt_T++;
				break;
			case LO_F:
				opt_F++;
				break;

			case '?':
				fprintf(stderr, "Try `%s --help' for more information.\n", argv[0]);
				exit(1);
			default:
				fprintf(stderr, "getopt returned character code %d\n", c);
				exit(1);
		}
	}

	// At least one program argument
	if (argc - optind < 1) {
		usage(argv, false);
		exit(1);
	}

	// test
	tree_t tree(1, 100, 0);

	for (int iArg = optind; iArg < argc; iArg++) {
		const char *pName = argv[iArg];

		if (pName[0] != '-' || pName[1] != 0) {
			// read from arg
			if (iArg == optind)
				tree.decodeFast(pName);
		} else {
			// read from stdin
			char *pBuffer = (char *) malloc(10000000);
			size_t rval = fread(pBuffer, 1, 10000000, stdin);
			if (rval == 10000000) {
				fprintf(stderr, "stdin too long\n");
				exit(1);
			}
			pBuffer[rval] = 0;
			tree.decodeFast(pBuffer);
			free(pBuffer);
		}

		printf("=%d [%s]\n", tree.count, tree.encodeTransform(tree.root));
	}

	return 0;
}
