//#pragma GCC optimize ("O0") // optimize on demand

/**
 * Source is based on ancient code and insights.
 * Code changes should be kept to an absolute minimum.
 * Don't be tempted...
 */

/*
 * @date 2020-03-06 16:56:25
 *
 * `eval` is the reference implementation of the basic concepts of this project
 * and is therefore the authoritative outcome in cases of dispute during regression testing.
 *
 *  `eval` self-test demonstrates:
 *   - Decoding and encoding of postfix notations
 *   - Constructing trees
 *   - Normalisations: 1:inverting, 1:function grouping, 2:dyadic ordering
 *   - Caching
 *   - Evaluating
 *
 *  @date 2020-03-29 15:17:13
 *
 *  There is a known issue that `encode()` with a entrypoint other than te root might not properly order endpoints.
 *  `"./eval 'ab+bc+a12!!' --Q --skin"`. You will find `"ca+"`
 */

/*
 *	This file is part of Untangle, Information in fractal structures.
 *	Copyright (C) 2017-2020, xyzzy@rockingship.org
 *
 *	This program is free software: you can redistribute it and/or modify
 *	it under the terms of the GNU General Public License as published by
 *	the Free Software Foundation, either version 3 of the License, or
 *	(at your option) any later version.
 *
 *	This program is distributed in the hope that it will be useful,
 *	but WITHOUT ANY WARRANTY; without even the implied warranty of
 *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *	GNU General Public License for more details.
 *
 *	You should have received a copy of the GNU General Public License
 *	along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#if 0
/*
 * @date 2020-03-06 17:59:31
 *
 * Reference implementation on how to use the output generated by `"--code"`
 *
 * The first array entry is reserved for the reference value `null/zero/false`
 * The next 9 entries are the input endpoints
 * The remainder entries are the QTF nodes
 */

#include <stdio.h>

int main() {
    for (unsigned a=0; a<2; a++)
    for (unsigned b=0; b<2; b++)
    for (unsigned c=0; c<2; c++) {

	unsigned bit = ({ unsigned _[] = {0,a,b,c, _[1]?_[2]:!_[3] }; !_[4];});

	printf("%u", bit);
    }
	printf("\n");

    return 0;
}
#endif

#include <stdint.h>
#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <string.h>
#include <getopt.h>

/*
 * Constants
 */

/// @constant {number} IBIT - Which bit of the operand is reserved to flag that the result needs to be inverted
#define IBIT 0x80000000
/// @constant {number} MAXSLOTS - Maximum number of slots/variables for the evaluator
#define MAXSLOTS 9
/// @constant {number} KSTART - Starting index in tree where to find the input endpoints.
#define KSTART 1
/// @constant {number} NEND - Maximum number of nodes the tree can contain. Keep large for selftest
#define NEND 20000
/// @constant {number} SBUFMAX - Maximum size of constructed notation. Roughly assuming 3 characters per operand and operator
#define SBUFMAX (10 * NEND)

/*
 * User specified program options
 */

/// @global {number} --quiet
unsigned opt_quiet      = 0;
/// @global {number} --verbose
unsigned opt_verbose    = 0;
/// @global {number} --skin, display notation with placeholders and skin
unsigned opt_skin       = 0;
/// @global {number} --code, output tree as gcc statement expression
unsigned opt_code       = 0;
/// @global {number} --fast, do not normalise input
unsigned opt_fast       = 0;
/// @global {number} --pure, `QTF->QnTF` rewriting
unsigned opt_pure       = 0;
/// @global {number} --seed=n, Random seed to generate evaluator test pattern
unsigned opt_seed       = 1;
/// @global {number} --shrinkwrap, Adjust nstart to highest found endpount
unsigned opt_shrinkwrap = 0;
/// @global {number} --Q, Select the `"question"` part of the top-level node
unsigned opt_Q          = 0;
/// @global {number} --T, Select the `"when-true"` part of the top-level node
unsigned opt_T          = 0;
/// @global {number} --F, Select the `"when-false"` part of the top-level node
unsigned opt_F          = 0;

/**
 * @date 2020-03-06 21:06:01
 *
 * Program usage. Keep high in source code for easy reference
 *
 * @param {string[]} argv - program arguments
 * @param {boolean} verbose - set to true for option descriptions
 */
void usage(char *argv[], bool verbose) {
	fprintf(stderr, "usage: %s <pattern> ...\n", argv[0]);
	if (verbose) {
		fprintf(stderr, "\t-c --code       Output tree as gcc statement expression\n");
		fprintf(stderr, "\t   --fast       Do not normalise input\n");
		fprintf(stderr, "\t-h --help       This list\n");
		fprintf(stderr, "\t   --pure       Output using exclusively  QnTF\n");
		fprintf(stderr, "\t-q --quiet      Say less\n");
		fprintf(stderr, "\t   --seed=n     Random seed to generate evaluator test pattern. [Default=%u]\n", opt_seed);
		fprintf(stderr, "\t   --selftest   Validate proper operation\n");
		fprintf(stderr, "\t   --shrinkwrap Adjust nstart to highest found endpount\n");
		fprintf(stderr, "\t-s --skin       Display notation with placeholders and skin mapping\n");
		fprintf(stderr, "\t-v --verbose    Say more\n");
		fprintf(stderr, "\t-Q --Q          Select top-level Q\n");
		fprintf(stderr, "\t-T --T          Select top-level T\n");
		fprintf(stderr, "\t-F --F          Select top-level F\n");
	}
}

/**
 * @date 2020-03-06 23:23:32
 *
 * struct representing a 512 bit vector, each bit representing the outcome of the unified operator for every possible state 9 variables can take
 * The vector is split into a collection of 64bit wide words.
 *
 * Test vectors are also used to compare equality of two trees
 *
 * As this is a reference implementation, `SIMD` instructions should be avoided.
 *
 * @typedef {number[]}
 */
struct footprint_t {
	/// @constant {number} QUADPERFOOTPRINT - Size of footprint in terms of uint64_t
	enum {
		QUADPERFOOTPRINT = ((1 << MAXSLOTS) / 64)
	};

	uint64_t bits[QUADPERFOOTPRINT]; // = 512/64 = 8 = QUADPERFOOTPRINT

	/**
	 * @date 2020-04-15 00:43:57
	 *
	 * Calculate the hash of a footprint.
	 *
	 * It doesn't really have to be crc,  as long as the result has some linear distribution over index.
	 * crc32 was chosen because it has a single assembler instruction on x86 platforms.
	 *
	 * Inspired by Mark Adler's software implementation of "crc32c.c -- compute CRC-32C using the Intel crc32 instruction"
	 *
	 * @return {number} - calculate crc
	 */
	uint32_t crc32(void) const {

		static uint32_t crc32c_table[8][256];

		if (crc32c_table[0][0] == 0) {
			/*
			 * Initialize table
			 */
			uint32_t n, crc, k;
			uint32_t poly = 0x82f63b78;

			for (n = 0; n < 256; n++) {
				crc = n;

				crc = (crc & 1) ? (crc >> 1) ^ poly : (crc >> 1);
				crc = (crc & 1) ? (crc >> 1) ^ poly : (crc >> 1);
				crc = (crc & 1) ? (crc >> 1) ^ poly : (crc >> 1);
				crc = (crc & 1) ? (crc >> 1) ^ poly : (crc >> 1);
				crc = (crc & 1) ? (crc >> 1) ^ poly : (crc >> 1);
				crc = (crc & 1) ? (crc >> 1) ^ poly : (crc >> 1);
				crc = (crc & 1) ? (crc >> 1) ^ poly : (crc >> 1);
				crc = (crc & 1) ? (crc >> 1) ^ poly : (crc >> 1);

				crc32c_table[0][n] = crc;
			}
			for (n = 0; n < 256; n++) {
				crc = crc32c_table[0][n];

				for (k = 1; k < 8; k++) {
					crc = crc32c_table[0][crc & 0xff] ^ (crc >> 8);
					crc32c_table[k][n] = crc;
				}
			}

		}

		/*
		 * Calculate crc
		 */
		uint64_t crc = 0;

		for (unsigned j = 0; j < QUADPERFOOTPRINT; j++) {

			crc ^= bits[j];

			crc = crc32c_table[7][crc & 0xff] ^
			      crc32c_table[6][(crc >> 8) & 0xff] ^
			      crc32c_table[5][(crc >> 16) & 0xff] ^
			      crc32c_table[4][(crc >> 24) & 0xff] ^
			      crc32c_table[3][(crc >> 32) & 0xff] ^
			      crc32c_table[2][(crc >> 40) & 0xff] ^
			      crc32c_table[1][(crc >> 48) & 0xff] ^
			      crc32c_table[0][crc >> 56];
		}

		return crc;
	}

};

/**
 * @date 2020-03-06 21:14:47
 *
 * Language structure representing the unified operator
 *
 * @typedef {object}
 */
struct node_t {
	/// @var {number} - reference to `"question"`
	uint32_t Q;
	/// @var {number} - reference to `"when-true"`. May have IBIT set
	uint32_t T;
	/// @var {number} - reference to `"when-false"`
	uint32_t F;
};

/**
 * @date 2020-03-06 21:45:08
 *
 * Language structure representing the fractal tree
 *
 * @typedef {object}
 */
struct tree_t {

	/// @var {number} index of first endpointvariable
	uint32_t kstart;

	/// @var {number} index of first operator node
	uint32_t nstart;

	/// @var {number} index of first free node
	uint32_t count;

	/// @var {node_t[]} array of unified operators
	node_t N[NEND];

	/// @var {number} single entrypoint/index where the result can be found
	uint32_t root;

	/**
 	 * @date 2020-03-06 21:46:08
 	 *
	 * Constructor
	 *
	 * @param {number} kstart - index of first endpoint
 	 * @param {number} kstart - nstart of first node
	 */

	inline tree_t(unsigned kstart, unsigned nstart)
		: kstart(kstart), nstart(nstart), count(nstart) {
	}

	/**
	 * @date 2020-03-06 22:30:00
	 *
	 * Copy constructor
	 *
	 * @param {tree_t} rhs - right hans side of assignment
	 * @return {tree_t} deep copy of object
	 */
	inline tree_t(const tree_t &rhs) {
		assert(!"copy constructor not supported");
	}

	/**
	 * @date 2020-03-06 21:47:08
	 *
	 * Assignment operator
	 *
	 * @param {tree_t} rhs - right hans side of assignment
	 * @return {tree_t} deep copy of object
	 */
	inline tree_t &operator=(const tree_t &rhs) {
		assert(!"assignment constructor not supported");

		// first members
		this->kstart = rhs.kstart;
		this->nstart = rhs.nstart;
		this->count  = rhs.count;

		// then nodes
		for (unsigned i = rhs.nstart; i < count; i++)
			this->N[i] = rhs.N[i];

		// roots last
		this->root = rhs.root;

		return *this;
	}

	/**
	 * @date 2020-03-06 22:27:36
	 *
	 * Erase the contents
	 */
	inline void clear(void) {
		this->count = this->nstart; // rewind first free node
		this->root  = 0; // set result to zero-reference
	}

	/**
	 * @date 2020-03-20 23:00:23
	 *
	 * for level-2 normalisation: dyadic ordering.
	 *
	 * Comparing the operand reference id's is not sufficient to determining ordering.
	 *
	 * For example `"ab+cd>&~"` and `"cd>ab+&~"` would be considered 2 different trees.
	 *
	 * To find them identical a deep inspection must occur
	 *
	 * @param {number} lhs - entrypoint to right side
	 * @param {number} rhs - entrypoint to right side
	 * @return {number} `-1` if `lhs<rhs`, `0` if `lhs==rhs` and `+1` if `lhs>rhs`
	 */
	int compare(unsigned lhs, unsigned rhs) {

		static uint8_t beenThere[NEND];

		static uint32_t stackL[NEND * 3]; // there are 3 operands per per opcode
		static uint32_t stackR[NEND * 3]; // there are 3 operands per per opcode
		int             stackPos = 0;

		assert(~lhs & IBIT);
		assert(~rhs & IBIT);

		stackL[stackPos] = lhs;
		stackR[stackPos] = rhs;
		stackPos++;

		// erase where been
		::memset(beenThere, 0, this->count * sizeof(*beenThere));

		do {
			// pop stack
			--stackPos;
			unsigned L = stackL[stackPos];
			unsigned R = stackR[stackPos];

			/*
			 * compare endpoints/references
			 */
			if (L < nstart && R >= nstart)
				return -1; // `end` < `ref`
			if (L >= nstart && R < nstart)
				return +1; // `ref` > `end`

			/*
			 * compare contents
			 */
			if (L < nstart) {
				if (L < R)
					return -1; // `lhs` < `rhs`
				if (L > R)
					return +1; // `lhs` < `rhs`

				// continue with next stack entry
				continue;
			}

			/*
			 * Been here before
			 */
			if (beenThere[L] == R)
				continue; // yes
			beenThere[L] = R;

			// decode L and R
			const node_t *pNodeL = this->N + L;
			const node_t *pNodeR = this->N + R;

			/*
			 * Reminder:
			 *  [ 2] a ? ~0 : b                  "+" OR
			 *  [ 6] a ? ~b : 0                  ">" GT
			 *  [ 8] a ? ~b : b                  "^" XOR
			 *  [ 9] a ? ~b : c                  "!" QnTF
			 *  [16] a ?  b : 0                  "&" AND
			 *  [19] a ?  b : c                  "?" QTF
			 */

			/*
			 * compare structure
			 */
			if ((pNodeL->T & IBIT) && (~pNodeR->T & IBIT))
				return -1; // `QnTF` < `QTF`
			if ((~pNodeL->T & IBIT) && (pNodeR->T & IBIT))
				return +1; // `QTF` > `QnTF`
			if (pNodeL->T == IBIT && pNodeR->T != IBIT)
				return -1; // `OR` < !`OR`
			if (pNodeL->T != IBIT && pNodeR->T == IBIT)
				return +1; // !`OR` > `OR`
			if (pNodeL->F == 0 && pNodeR->F != 0)
				return -1; // `GT` < !`GT` or `AND` < !`AND`
			if (pNodeL->F != 0 && pNodeR->F == 0)
				return +1; // !`GT` > `GT` or !`AND` > `AND`
			if (pNodeL->F == (pNodeL->T ^ IBIT) && pNodeR->F != (pNodeR->T ^ IBIT))
				return -1; // `XOR` < !`XOR`
			if (pNodeL->F != (pNodeL->T ^ IBIT) && pNodeR->F == (pNodeR->T ^ IBIT))
				return +1; // !`XOR` > `XOR`


			/*
			 * Push natural walking order
			 * deep Q, deep T, deep F, endpoint Q, endpoint T, endpoint F
			 *
			 */
			if (pNodeL->F) {
				if (pNodeL->F < nstart && pNodeR->F < nstart) {
					stackL[stackPos] = pNodeL->F;
					stackR[stackPos] = pNodeR->F;
					stackPos++;
				}
			}
			if (pNodeL->T & ~IBIT) {
				if ((pNodeL->T & ~IBIT) < nstart && (pNodeR->T & ~IBIT) < nstart) {
					stackL[stackPos] = pNodeL->T & ~IBIT;
					stackR[stackPos] = pNodeR->T & ~IBIT;
					stackPos++;
				}
			}
			if (pNodeL->Q) {
				if (pNodeL->Q < nstart && pNodeR->Q < nstart) {
					stackL[stackPos] = pNodeL->Q;
					stackR[stackPos] = pNodeR->Q;
					stackPos++;
				}
			}
			if (pNodeL->F) {
				if (pNodeL->F >= nstart || pNodeR->F >= nstart) {
					stackL[stackPos] = pNodeL->F;
					stackR[stackPos] = pNodeR->F;
					stackPos++;
				}
			}
			if (pNodeL->T & ~IBIT) {
				if ((pNodeL->T & ~IBIT) >= nstart || (pNodeR->T & ~IBIT) >= nstart) {
					stackL[stackPos] = pNodeL->T & ~IBIT;
					stackR[stackPos] = pNodeR->T & ~IBIT;
					stackPos++;
				}
			}
			if (pNodeL->Q) {
				if (pNodeL->Q >= nstart || pNodeR->Q >= nstart) {
					stackL[stackPos] = pNodeL->Q;
					stackR[stackPos] = pNodeR->Q;
					stackPos++;
				}
			}

		} while (stackPos > 0);

		// identical
		return 0;
	}

	/**
	 * @date 2020-03-09 16:27:10
	 *
	 * Perform level 1 normalisation on a `"Q,T,F"` triplet and add to the tree only when unique.
	 *
	 * Level 1 Normalisations include: inverting, function grouping, dyadic ordering and `QTF->QnTF` rewriting.
	 *
	 * @param {number} Q
	 * @param {number} T
	 * @param {number} F
	 * @return {number} index into the tree pointing to a node with identical functionality. May have `IBIT` set to indicate that the result is inverted.
	 */
	unsigned addNode(unsigned Q, unsigned T, unsigned F) {

		if (true) {
			assert((Q & ~IBIT) < this->count);
			assert((T & ~IBIT) < this->count);
			assert((F & ~IBIT) < this->count);
		}

		/*
		 * Level 1a - Inverts
		 *
		 * ~q ?  t :  f  ->  q ? f : t
		 *  0 ?  t :  f  ->  f
		 *  q ?  t : ~f  ->  ~(q ? ~t : f)
		 */

		if (Q & IBIT) {
			// "~Q?T:F" -> "Q?F:T"
			unsigned savT = T;
			T = F;
			F = savT;
			Q ^= IBIT;
		}
		if (Q == 0) {
			// "0?T:F" -> "F"
			return F;
		}

		// ibit indicates the result should be inverted
		unsigned ibit = 0;

		if (F & IBIT) {
			// "Q?T:~F" -> "~(Q?~T:F)"
			F ^= IBIT;
			T ^= IBIT;
			ibit ^= IBIT;
		}

		/*
		 * Level 1b: Function grouping
		 *
		 * appreciated:
		 *
		 *  [ 0] a ? ~0 : 0  ->  a
		 *  [ 1] a ? ~0 : a  ->  a ? ~0 : 0
		 *  [ 2] a ? ~0 : b                  "+" or
		 *  [ 3] a ? ~a : 0  ->  0
		 *  [ 4] a ? ~a : a  ->  a ? ~a : 0
		 *  [ 5] a ? ~a : b  ->  b ? ~a : b
		 *  [ 6] a ? ~b : 0                  ">" greater-than
		 *  [ 7] a ? ~b : a  ->  a ? ~b : 0
		 *  [ 8] a ? ~b : b                  "^" xor/not-equal
		 *  [ 9] a ? ~b : c                  "!" QnTF
		 *
		 * depreciated:
		 *  [10] a ?  0 : 0 -> 0
		 *  [11] a ?  0 : a -> 0
		 *  [12] a ?  0 : b -> b ? ~a : 0    "<" less-than
		 *  [13] a ?  a : 0 -> a
		 *  [14] a ?  a : a -> a ?  a : 0
		 *  [15] a ?  a : b -> a ? ~0 : b
		 *  [16] a ?  b : 0                  "&" and
		 *  [17] a ?  b : a -> a ?  b : 0
		 *  [18] a ?  b : b -> b
		 *  [19] a ?  b : c                  "?" QTF
		 *
		 * ./eval --fast 'a00!' 'a0a!' 'a0b!' 'aa0!' 'aaa!' 'aab!' 'ab0!' 'aba!' 'abb!' 'abc!' 'a00?' 'a0a?' 'a0b?' 'aa0?' 'aaa?' 'aab?' 'ab0?' 'aba?' 'abb?' 'abc?'
		 */

		if (T & IBIT) {

			if (T == IBIT) {
				if (F == Q || F == 0) {
					// SELF
					// "Q?~0:Q" [1] -> "Q?~0:0" [0] -> Q
					return Q ^ ibit;
				} else {
					// OR
					// "Q?~0:F" [2]
				}
			} else if ((T & ~IBIT) == Q) {
				if (F == Q || F == 0) {
					// ZERO
					// "Q?~Q:Q" [4] -> "Q?~Q:0" [3] -> "0"
					return 0 ^ ibit;
				} else {
					// LESS-THAN
					// "Q?~Q:F" [5] -> "F?~Q:F" -> "F?~Q:0"
					Q = F;
					F = 0;
				}
			} else {
				if (F == Q || F == 0) {
					// GREATER-THAN
					// "Q?~T:Q" [7] -> "Q?~T:0" [6]
					F = 0;
				} else if ((T & ~IBIT) == F) {
					// XOR/NOT-EQUAL
					// "Q?~F:F" [8]
				} else {
					// QnTF
					// "Q?~T:F" [9]
				}
			}

		} else {

			if (T == 0) {
				if (F == Q || F == 0) {
					// ZERO
					// "Q?0:Q" [11] -> "Q?0:0" [10] -> "0"
					return 0 ^ ibit;
				} else {
					// LESS-THAN
					// "Q?0:F" [12] -> "F?~Q:0" [6]
					T = Q ^ IBIT;
					Q = F;
					F = 0;
				}

			} else if (T == Q) {
				if (F == Q || F == 0) {
					// SELF
					// "Q?Q:Q" [14] -> Q?Q:0" [13] -> "Q"
					return Q ^ ibit;
				} else {
					// OR
					// "Q?Q:F" [15] -> "Q?~0:F" [2]
					T = 0 ^ IBIT;
				}
			} else {
				if (F == Q || F == 0) {
					// AND
					// "Q?T:Q" [17] -> "Q?T:0" [16]
					F = 0;
				} else if (T == F) {
					// SELF
					// "Q?F:F" [18] -> "F"
					return F ^ ibit;
				} else {
					// QTF
					// "Q?T:F" [19]
				}
			}
		}

		/*
		 * Level 1c - dyadic ordering
		 *
		 */

		// `OR` `Q?~0:F` where Q>F
		if (T == IBIT && this->compare(Q, F) > 0) {
			// swap
			unsigned savQ = Q;
			Q = F;
			F = savQ;
		}

		// `XOR` `Q?~F:F` where Q>F
		if ((T ^ IBIT) == F && this->compare(Q, F) > 0) {
			// swap
			unsigned savQ = Q;
			Q = F;
			F = savQ;
			T = savQ ^ IBIT;
		}

		// `AND` `Q?T:0` where Q>T
		if ((~T & IBIT) && F == 0 && this->compare(Q, T) > 0) {
			// swap
			unsigned savQ = Q;
			Q = T;
			T = savQ;
		}

		/**
		 ** This is where you would put additional normalisations
		 **/

		/*
		 * Directly before caching, rewrite `QTF` to `QnTF`
		 *
		 * a ?  b : c -> a?~(a?~b:c):c  "?" QTF
		 *
		 * ./eval --pure 'ab&' 'abc?'
		 */

		if (opt_pure && (~T & IBIT)) {
			// QTF
			// Q?T:F -> Q?~(Q?~T:F):F)
			T = addNode(Q, T ^ IBIT, F) ^ IBIT;
		}

		// sanity checking
		if (true) {
			// level-1
			assert(~Q & IBIT);                     // Q not inverted
			assert(~F & IBIT);                     // F not inverted
			assert(Q != 0);                        // Q not zero
			assert(T != 0);                        // Q?0:F -> F?!Q:0
			assert(T != IBIT || F != 0);           // Q?!0:0 -> Q
			assert(Q != (T & ~IBIT));              // Q/T collapse
			assert(Q != F);                        // Q/F collapse
			assert(T != F);                        // T/F collapse
			// level-2
			assert(T != IBIT || this->compare(Q, F) < 0);            // OR ordering
			assert((T & ~IBIT) != F || this->compare(Q, F) < 0);     // NE ordering
			assert(F != 0 || (T & IBIT) || this->compare(Q, T) < 0); // AND ordering
		}

		/*
		 * @date 2020-03-10 00:57:36
		 *
		 * At this point the structure has achieved its most prime form
		 *
		 * Basic fractal recursion occurs here by reusing previous occurrences of `q`,`t`,`f`
		 *
		 * The following code is a stub for level-2 normalisation
		 */

		/*
		 * Extremely simple and slow array based list lookup
		 */

		// test if already cached
		for (unsigned i = this->nstart; i < this->count; i++) {
			node_t *pNode = this->N + i;
			if (pNode->Q == Q && pNode->T == T && pNode->F == F)
				return i ^ ibit;
		}

		// create new entry
		unsigned nid    = this->count++;
		node_t   *pNode = this->N + nid;

		// populate
		pNode->Q = Q;
		pNode->T = T;
		pNode->F = F;

		return nid ^ ibit;
	}

	/**
	 * @date 2020-03-09 10:31:50
	 *
	 * scan notation, find highest endpoint and decode optional skin
	 *
	 * @param {string} pName - notation and skin separated by '/'
	 * @param {number[1]} pHighestEndpoint - return highest found endpoint in either notation or skin
	 * @param {number[1]} pNumSkin - return number of skin elements. This might be higher than the number of placeholders
	 * @param {number[]} pSkin - decoded list skins elements
	 */
	void decodeEndpoints(const char *pName, unsigned *pHighestEndpoint, unsigned *pNumSkin, uint32_t *pSkin) const {

		unsigned prefix          = 0; // current prefix
		unsigned highestEndpoint = 0; // highest endpoints
		unsigned numSkin         = 0; // number of skin elements

		/*
		 * walk through the notation until end or until placeholder/skin separator
		 */
		for (; *pName != 0 && *pName != '/'; pName++) {

			// skip spaces
			if (isspace(*pName))
				continue;

			// test for prefix/endpoint
			if (isupper(*pName)) {
				// expand prefix
				prefix = prefix * 26 + *pName - 'A';

			} else if (islower(*pName)) {
				// endpoint
				unsigned ep = prefix * 26 + *pName - 'a';

				// remember highest
				if (ep > highestEndpoint)
					highestEndpoint = ep;

				// reset prefix
				prefix = 0;

			} else {
				// something else
				prefix = 0;
			}
		}

		/*
		 * test for separator
		 */
		if (*pName != '/') {
			// missing separator
			*pHighestEndpoint = highestEndpoint; // highest endpoint in basic notation
			*pNumSkin         = 0; // no skin
			return;
		}

		/*
		 * decode the skin
		 */

		// skip separator
		pName++;
		// skin contains the final endpoints, reset highest
		highestEndpoint = 0;

		// walk through the notation until end
		for (; *pName != 0; pName++) {

			// skip spaces
			if (isspace(*pName))
				continue;

			// test for prefix/endpoint
			if (isupper(*pName)) {
				// expand prefix
				prefix = prefix * 26 + *pName - 'A';

			} else if (islower(*pName)) {
				// endpoint
				unsigned ep = prefix * 26 + *pName - 'a';

				// store in binary skin
				pSkin[numSkin++] = ep;

				// remember highest
				if (ep > highestEndpoint)
					highestEndpoint = ep;

				// reset prefix
				prefix = 0;

			} else {
				// something else
				prefix = 0;
			}
		}

		// return result
		*pHighestEndpoint = highestEndpoint; // highest endpoint in skin
		*pNumSkin         = numSkin; // number of skin elements
	}

	/**
	 * @date 2020-03-09 17:05:36
	 *
	 * Parse notation and construct tree accordingly.
	 * Notation is assumed to be normalised.
	 *
	 * Do not spend too much effort on detailing errors
	 *
	 * @param {string} pName - The notation describing the tree
	 * @param {number} numSkin - size of `pSkin[]`
	 * @param {number[]}} pSkin - zero based list of skin elements
	 * @return non-zero when parsing failed
	 */
	int decodeSafe(const char *pName, unsigned numSkin, const uint32_t *pSkin) {

		// initialise tree
		this->count = this->nstart;
		this->root  = 0;

		// initialise state
		nextNode                     = this->nstart;

		// temporary stack storage for postfix notation
		static uint32_t stack[NEND];
		int             stackPos     = 0;
		unsigned        prefix       = 0;
		uint32_t        nestStack[16];
		unsigned        nestStackPos = 0;


		// walk through the notation until end or until placeholder/skin separator
		for (const char *pCh = pName; *pCh != 0 && *pCh != '/'; pCh++) {

			// skip spaces
			if (isspace(*pCh))
				continue;

			// test for prefix
			if (isupper(*pCh)) {
				prefix = prefix * 26 + *pCh - 'A';
				continue;
			}

			// test for endpoint
			if (islower(*pCh)) {
				// determine endpoint value
				unsigned ep = prefix * 26 + *pCh - 'a'; // endpoint

				// test if placeholder
				if (numSkin != 0) {
					// range check
					if (ep >= numSkin) {
						printf("[placeholder out-of-range: %u]\n", ep);
						return 1;
					}

					// dereference placeholder
					ep = pSkin[ep];
				}

				// get final nodeId
				unsigned nid = this->kstart + ep; // nodeId is endpoint relative to kstart

				// range check
				if (nid >= this->nstart) {
					printf("[endpoint out-of-range. nid=%u]\n", nid);
					return 1;
				}

				if (stackPos >= NEND) {
					printf("[stack overflow]\n");
					return 1;
				}

				// reset prefix
				prefix = 0;

				// Push the index of the endpoint onto the stack
				stack[stackPos++] = nid;
				continue;
			}

			// test for back-reference
			// loading is non-normalised and each opcode symbol populates exactly one node making calculations fairly easy
			if (isdigit(*pCh)) {
				unsigned nid; // node id

				// determine final value
				nid = prefix * 10 + *pCh - '0';

				// reset prefix
				prefix = 0;

				// range check
				if (stackPos >= NEND) {
					printf("[stack overflow]\n");
					return 1;
				}

				// special case: '0' is actually zero
				if (nid == 0) {
					stack[stackPos++] = 0;
					continue;
				}

				// convert visual relative to visual absolute index
				nid = nextNode - nid;

				// rangecheck
				if (nid < this->nstart || nid >= nextNode) {
					printf("[back reference out-of-range. nid=%u]\n", nid);
					return 1;
				}

				/*
				 * NOTE: nid is the 'visual' back-reference.
				 * Node normalisation may effectively add/remove nodes runtime.
				 * `beenThere[]` maps visual id's to actual id's
				 */
				nid = beenThere[nid];

				// Push the index of the back reference onto the stack
				stack[stackPos++] = nid;
				continue;
			}

			// prefix must be zero
			if (prefix) {
				printf("[non-zero prefix]\n");
				return 1;
			}

			/*
			 * non-documented feature: opcodes `"("` and "`)"` to allow manual sub-tree substitution.
			 * It is not documented because it has no checks on validity.
			 *
			 * Given the tree `"ab+c&2>"`, the back-reference `"2"` points to `"ab+"`
			 *
			 * However, if `"c"` would be manually replaced by a smaller tree, the notation would break
			 * because the relative back-reference did not take into account the extra nodes.
			 *
			 * This is solved by placing the substition within parenthesis which restores back-reference offsets.
			 */
			if (*pCh == '(') {
				nestStack[nestStackPos++] = nextNode;
				continue;
			} else if (*pCh == ')') {
				nextNode = nestStack[--nestStackPos];
				continue;
			}

			// test if new operator will fit
			if (this->count >= NEND) {
				printf("[tree too large]\n");
				return 1;
			}

			switch (*pCh) {
			case '>': {
				// GT (appreciated)
				if (stackPos < 2) {
					printf("[stack underflow]\n");
					return 1;
				}

				//pop operands
				unsigned R = stack[--stackPos]; // right hand side
				unsigned L = stack[--stackPos]; // left hand side

				if ((L & ~IBIT) >= this->count || (R & ~IBIT) >= this->count) {
					printf("[operand out-of-range]\n");
					return 1;
				}

				// create operator
				unsigned nid = addNode(L, R ^ IBIT, 0);

				// push
				stack[stackPos++] = nid;

				// save actual index for back references
				beenThere[nextNode++] = nid;
				break;
			}

			case '^': {
				// XOR (appreciated)
				if (stackPos < 2) {
					printf("[stack underflow]\n");
					return 1;
				}

				//pop operands
				unsigned R = stack[--stackPos]; // right hand side
				unsigned L = stack[--stackPos]; // left hand side

				if ((L & ~IBIT) >= this->count || (R & ~IBIT) >= this->count) {
					printf("[operand out-of-range]\n");
					return 1;
				}

				// create operator
				unsigned nid = addNode(L, R ^ IBIT, R);

				// push
				stack[stackPos++] = nid;

				// save actual index for back references
				beenThere[nextNode++] = nid;
				break;
			}

			case '+': {
				// OR (appreciated)
				if (stackPos < 2) {
					printf("[stack underflow]\n");
					return 1;
				}

				// pop operands
				unsigned R = stack[--stackPos]; // right hand side
				unsigned L = stack[--stackPos]; // left hand side

				if ((L & ~IBIT) >= this->count || (R & ~IBIT) >= this->count) {
					printf("[operand out-of-range]\n");
					return 1;
				}

				// create operator
				unsigned nid = addNode(L, 0 ^ IBIT, R);

				// push
				stack[stackPos++] = nid;

				// save actual index for back references
				beenThere[nextNode++] = nid;
				break;
			}

			case '!': {
				// QnTF (appreciated)
				if (stackPos < 3) {
					printf("[stack underflow]\n");
					return 1;
				}

				// pop operands
				unsigned F = stack[--stackPos];
				unsigned T = stack[--stackPos];
				unsigned Q = stack[--stackPos];

				if ((Q & ~IBIT) >= this->count || (T & ~IBIT) >= this->count || (F & ~IBIT) >= this->count) {
					printf("[operand out-of-range]\n");
					return 1;
				}

				// create operator
				unsigned nid = addNode(Q, T ^ IBIT, F);

				// push
				stack[stackPos++] = nid;

				// save actual index for back references
				beenThere[nextNode++] = nid;
				break;
			}

			case '&': {
				// AND (depreciated)
				if (stackPos < 2) {
					printf("[stack underflow]\n");
					return 1;
				}

				// pop operands
				unsigned R = stack[--stackPos]; // right hand side
				unsigned L = stack[--stackPos]; // left hand side

				if ((L & ~IBIT) >= this->count || (R & ~IBIT) >= this->count) {
					printf("[operand out-of-range]\n");
					return 1;
				}

				// create operator
				unsigned nid = addNode(L, R, 0);

				// push
				stack[stackPos++] = nid;

				// save actual index for back references
				beenThere[nextNode++] = nid;
				break;
			}

			case '?': {
				// QTF (depreciated)
				if (stackPos < 3) {
					printf("[stack underflow]\n");
					return 1;
				}

				// pop operands
				unsigned F = stack[--stackPos];
				unsigned T = stack[--stackPos];
				unsigned Q = stack[--stackPos];

				if ((Q & ~IBIT) >= this->count || (T & ~IBIT) >= this->count || (F & ~IBIT) >= this->count) {
					printf("[operand out-of-range]\n");
					return 1;
				}

				// create operator
				unsigned nid = addNode(Q, T, F);

				// push
				stack[stackPos++] = nid;

				// save actual index for back references
				beenThere[nextNode++] = nid;
				break;
			}

			case '~': {
				// NOT (support)
				if (stackPos < 1) {
					printf("[stack underflow]\n");
					return 1;
				}

				// invert top-of-stack
				stack[stackPos - 1] ^= IBIT;

				break;
			}

			case '<': {
				// LT (support)
				if (stackPos < 2) {
					printf("[stack underflow]\n");
					return 1;
				}

				//pop operands
				unsigned R = stack[--stackPos]; // right hand side
				unsigned L = stack[--stackPos]; // left hand side

				if ((L & ~IBIT) >= this->count || (R & ~IBIT) >= this->count) {
					printf("[operand out-of-range]\n");
					return 1;
				}

				// create operator
				unsigned nid = addNode(L, 0, R);

				// push
				stack[stackPos++] = nid;

				// save actual index for back references
				beenThere[nextNode++] = nid;
				break;
			}

			default:
				printf("[bad token: %c]\n", *pCh);
				return 1;
			}
		}

		if (stackPos != 1) {
			printf("[unbalanced]\n");
			return 1;
		}

		// store result into root
		this->root = stack[stackPos - 1];
		return 0;
	}

	/**
	 * @date 2020-03-07 00:12:44
	 *
	 * Parse notation and construct tree accordingly.
	 * Notation is taken literally and not normalised
	 *
	 * Do not spend too much effort on detailing errors
	 *
	 * @param {string} pName - The notation describing the tree
	 * @param {number} numSkin - size of `pSkin[]`
	 * @param {number[]}} pSkin - zero based list of skin elements
	 * @return non-zero when parsing failed
	 */
	int decodeFast(const char *pName, unsigned numSkin, const uint32_t *pSkin) {

		// initialise tree
		this->count              = this->nstart;
		this->root               = 0;

		// temporary stack storage for postfix notation
		static uint32_t stack[NEND];
		int             stackPos = 0;
		unsigned        prefix   = 0;

		// walk through the notation until end or until placeholder/skin separator
		for (const char *pCh = pName; *pCh != 0 && *pCh != '/'; pCh++) {

			// skip spaces
			if (isspace(*pCh))
				continue;

			// test for prefix
			if (isupper(*pCh)) {
				prefix = prefix * 26 + *pCh - 'A';
				continue;
			}

			// test for endpoint
			if (islower(*pCh)) {
				// determine endpoint value
				unsigned ep = prefix * 26 + *pCh - 'a'; // endpoint

				// test if placeholder
				if (numSkin != 0) {
					// range check
					if (ep >= numSkin) {
						printf("[placeholder out-of-range: %u]\n", ep);
						return 1;
					}

					// dereference placeholder
					ep = pSkin[ep];
				}

				// get final nodeId
				unsigned nid = this->kstart + ep; // nodeId is endpoint relative to kstart

				// range check
				if (nid >= this->nstart) {
					printf("[endpoint out-of-range. nid=%u]\n", nid);
					return 1;
				}

				if (stackPos >= NEND) {
					printf("[stack overflow]\n");
					return 1;
				}

				// reset prefix
				prefix = 0;

				// Push the index of the endpoint onto the stack
				stack[stackPos++] = nid;
				continue;
			}

			// test for back-reference
			// loading is non-normalised and each opcode symbol populates exactly one node making calculations fairly easy
			if (isdigit(*pCh)) {
				unsigned nid; // node id

				// determine final value
				nid = prefix * 10 + *pCh - '0';

				// reset prefix
				prefix = 0;

				// range check
				if (stackPos >= NEND) {
					printf("[stack overflow]\n");
					return 1;
				}

				// special case: '0' is actually zero
				if (nid == 0) {
					stack[stackPos++] = 0;
					continue;
				}

				// convert relative to absolute index
				nid = this->count - nid;

				// rangecheck
				if (nid < this->nstart || nid >= this->count) {
					printf("[back reference out-of-range. nid=%u]\n", nid);
					return 1;
				}

				// Push the index of the back reference onto the stack
				stack[stackPos++] = nid;
				continue;
			}

			// prefix must be zero
			if (prefix) {
				printf("[non-zero prefix]\n");
				return 1;
			}

			// test if new operator will fit
			if (this->count >= NEND) {
				printf("[tree too large]\n");
				return 1;
			}

			switch (*pCh) {
			case '>': {
				// GT (appreciated)
				if (stackPos < 2) {
					printf("[stack underflow]\n");
					return 1;
				}

				//pop operands
				unsigned R = stack[--stackPos]; // right hand side
				unsigned L = stack[--stackPos]; // left hand side

				if ((L & IBIT) || (R & IBIT)) {
					printf("[invert not normalised]\n");
					return 1;
				}
				if (L >= this->count || R >= this->count) {
					printf("[operand out-of-range]\n");
					return 1;
				}

				// create operator
				this->N[this->count].Q = L;
				this->N[this->count].T = R ^ IBIT;
				this->N[this->count].F = 0;

				// push
				stack[stackPos++] = this->count++;
				break;
			}

			case '^': {
				// XOR (appreciated)
				if (stackPos < 2) {
					printf("[stack underflow]\n");
					return 1;
				}

				//pop operands
				unsigned R = stack[--stackPos]; // right hand side
				unsigned L = stack[--stackPos]; // left hand side

				if ((L & IBIT) || (R & IBIT)) {
					printf("[invert not normalised]\n");
					return 1;
				}
				if (L >= this->count || R >= this->count) {
					printf("[operand out-of-range]\n");
					return 1;
				}

				// create operator
				this->N[this->count].Q = L;
				this->N[this->count].T = R ^ IBIT;
				this->N[this->count].F = R;

				// push
				stack[stackPos++] = this->count++;
				break;
			}

			case '+': {
				// OR (appreciated)
				if (stackPos < 2) {
					printf("[stack underflow]\n");
					return 1;
				}

				// pop operands
				unsigned R = stack[--stackPos]; // right hand side
				unsigned L = stack[--stackPos]; // left hand side

				if ((L & IBIT) || (R & IBIT)) {
					printf("[invert not normalised]\n");
					return 1;
				}
				if (L >= this->count || R >= this->count) {
					printf("[operand out-of-range]\n");
					return 1;
				}

				// create operator
				this->N[this->count].Q = L;
				this->N[this->count].T = 0 ^ IBIT;
				this->N[this->count].F = R;

				// push
				stack[stackPos++] = this->count++;
				break;
			}

			case '!': {
				// QnTF (appreciated)
				if (stackPos < 3) {
					printf("[stack underflow]\n");
					return 1;
				}

				// pop operands
				unsigned F = stack[--stackPos];
				unsigned T = stack[--stackPos];
				unsigned Q = stack[--stackPos];

				if ((Q & IBIT) || (T & IBIT) || (F & IBIT)) {
					printf("[invert not normalised]\n");
					return 1;
				}
				if (Q >= this->count || T >= this->count || F >= this->count) {
					printf("[operand out-of-range]\n");
					return 1;
				}

				// create operator
				this->N[this->count].Q = Q;
				this->N[this->count].T = T ^ IBIT;
				this->N[this->count].F = F;

				// push
				stack[stackPos++] = this->count++;
				break;
			}

			case '&': {
				// AND (depreciated)
				if (stackPos < 2) {
					printf("[stack underflow]\n");
					return 1;
				}

				// pop operands
				unsigned R = stack[--stackPos]; // right hand side
				unsigned L = stack[--stackPos]; // left hand side

				if ((L & IBIT) || (R & IBIT)) {
					printf("[invert not normalised]\n");
					return 1;
				}
				if (L >= this->count || R >= this->count) {
					printf("[operand out-of-range]\n");
					return 1;
				}

				// create operator
				this->N[this->count].Q = L;
				this->N[this->count].T = R;
				this->N[this->count].F = 0;

				// push
				stack[stackPos++] = this->count++;
				break;
			}

			case '?': {
				// QTF (depreciated)
				if (stackPos < 3) {
					printf("[stack underflow]\n");
					return 1;
				}

				// pop operands
				unsigned F = stack[--stackPos];
				unsigned T = stack[--stackPos];
				unsigned Q = stack[--stackPos];

				if ((Q & IBIT) || (T & IBIT) || (F & IBIT)) {
					printf("[invert not normalised]\n");
					return 1;
				}
				if (Q >= this->count || T >= this->count || F >= this->count) {
					printf("[operand out-of-range]\n");
					return 1;
				}

				this->N[this->count].Q = Q;
				this->N[this->count].T = T;
				this->N[this->count].F = F;

				// push
				stack[stackPos++] = this->count++;
				break;
			}

			case '~': {
				// NOT (support)
				if (stackPos < 1) {
					printf("[stack underflow]\n");
					return 1;
				}

				// invert top-of-stack
				stack[stackPos - 1] ^= IBIT;

				break;
			}

			case '<': {
				// LT (support)
				if (stackPos < 2) {
					printf("[stack underflow]\n");
					return 1;
				}

				//pop operands
				unsigned R = stack[--stackPos]; // right hand side
				unsigned L = stack[--stackPos]; // left hand side

				if ((L & IBIT) || (R & IBIT)) {
					printf("[invert not normalised]\n");
					return 1;
				}
				if (L >= this->count || R >= this->count) {
					printf("[operand out-of-range]\n");
					return 1;
				}

				// create operator
				this->N[this->count].Q = L;
				this->N[this->count].T = 0;
				this->N[this->count].F = R;

				// push
				stack[stackPos++] = this->count++;
				break;
			}

			default:
				printf("[bad token: %c]\n", *pCh);
				return 1;
			}
		}

		if (stackPos != 1) {
			printf("[unbalanced]\n");
			return 1;
		}

		// store result into root
		this->root = stack[stackPos - 1];
		return 0;
	}

	/**
	 * @date 2020-03-10 22:22:33
	 *
	 * Parse notation and construct tree accordingly.
	 * Notation is assumed to be normalised.
	 *
	 * @param {string} pName - The notation describing the tree
	 * @param {boolean} shrinkwrap - Shrinkwrap nstart
	 * @return non-zero when parsing failed
	 */
	int decode(const char *pName, bool shrinkwrap) {
		unsigned highestEndpoint, numSkin;

		// get visual highest nstart
		this->decodeEndpoints(pName, &highestEndpoint, &numSkin, this->skin);

		this->nstart = this->kstart + highestEndpoint + 1;
		if (!shrinkwrap) {
			// normally this program is used to test `Xn9` datasets.
			// assume trees have at least 9 endpoints
			if (this->kstart + MAXSLOTS > this->nstart)
				this->nstart = this->kstart + MAXSLOTS;
		}

		// decode with explicit temporary storage for `pSkin`
		if (opt_fast) {
			if (this->decodeFast(pName, numSkin, this->skin))
				return 1; // decoding failed
		} else {
			if (this->decodeSafe(pName, numSkin, this->skin))
				return 1; // decoding failed
		}

		return 0;
	}

	/*
	 * @date 2020-03-07 15:31:50
	 *
	 * Composing the tree notation requires state information
         */

	/// @var {number} First free placeholder, or zero for no placeholder/skin mapping
	unsigned nextPlaceholder;
	/// @var {number} First free node
	unsigned nextNode;
	/// @var {string} Storage for notation
	char     sbuf[SBUFMAX];
	/// @var {number} length of notation
	unsigned spos;
	/// @var {number[]} for endpoints the placeholder/skin index, for nodes the nodeId of already emitted notations
	uint32_t beenThere[NEND];
	/// @var {number[]} the actual nodeId indexed by endpoint placeholder
	uint32_t skin[NEND];
	/// @var {boolean} non-zero if placeholders are in sync with skin
	bool     placeholdersInSync;

	/**
	 * @date 2020-03-10 20:20:55
	 *
	 * Encoding with placeholders is two-pass.
	 * Pass-1 locating and assigning placeholders
	 * Pass-2 emiting variable length placeholder names
	 *
	 * @param {number} id - index of node to encode
	 */
	void encodePlaceholders(unsigned id) {

		// extract all parts of the node
		unsigned T  = this->N[id].T;
		unsigned Tu = T & ~IBIT; // index to `T` operand
		unsigned Q  = this->N[id].Q;
		unsigned F  = this->N[id].F;

		// assert node is invert normalised
		assert((~Q & IBIT) && (~F & IBIT));

		/*
		 * Handle oldest children first
		 */
		if (Q >= this->nstart && beenThere[Q] == 0)
			encodePlaceholders(Q);
		if (Tu >= this->nstart && beenThere[Tu] == 0)
			encodePlaceholders(Tu);
		if (F >= this->nstart && beenThere[F] == 0)
			encodePlaceholders(F);

		/*
		 * Assign placeholders
		 */
		if (Q >= this->kstart && Q < this->nstart && beenThere[Q] == 0) {
			// save nodeId in skin
			skin[nextPlaceholder] = Q;

			// test if placeholders are still in sync
			if (Q != nextPlaceholder)
				placeholdersInSync = false; // out of sync

			// save skin index as endpoint placeholder
			beenThere[Q] = nextPlaceholder++;
		}
		if (Tu >= this->kstart && Tu < this->nstart && beenThere[Tu] == 0) {
			// save nodeId in skin
			skin[nextPlaceholder] = Tu;

			// test if placeholders are still in sync
			if (Tu != nextPlaceholder)
				placeholdersInSync = false; // out of sync

			// save skin index as endpoint placeholder
			beenThere[Tu] = nextPlaceholder++;
		}
		if (F >= this->kstart && F < this->nstart && beenThere[F] == 0) {
			// save nodeId in skin
			skin[nextPlaceholder] = F;

			// test if placeholders are still in sync
			if (F != nextPlaceholder)
				placeholdersInSync = false; // out of sync

			// save skin index as endpoint placeholder
			beenThere[F] = nextPlaceholder++;
		}

		/*
		 * Mark done
		 */
		beenThere[id] = nextNode++;
	}

	/**
	 * @date 2020-03-08 22:26:23
	 *
	 * Encode the tree index of a given node in "placeholder/skin" notation.
	 * for endpoints (id < nstart) emit placeholder as index to `pSkin` containing actual endpoint
	 * for nodes (id >= nstart) emit back reference reflecting the relative distance
	 *
	 * Optionally prefix endpoint/node with base26 prefix consisting of capital letters
	 *
	 * NOTE: uses recursion which might break on extremely large trees, which is not expected for this program.
	 *
	 * @param {number} id - index of node to encode
	 */
	void encodeOperand(unsigned id) {

		if (id == 0) {
			// may happen with non-normalised nodes like `"q?~0:0"`
			assert(spos + 1 < SBUFMAX - 1);
			sbuf[spos++] = '0';

		} else if (id < this->kstart) {
			// all operands must be >= KSTART
			assert(0);

		} else if (id < this->nstart) {

			// endpoints are notated as a lowercase letter (`'a'` resembling KSTART) base26 prefixed by uppercase letters
			char prefixStack[16];
			int  prefixStackPos = 0;

			// flag endpoint was encountered
			if (beenThere[id] == 0)
				beenThere[id] = id;

			// zero-based copy of placeholder
			unsigned v = beenThere[id] - this->kstart;

			// base26 encoded endpoint
			prefixStack[prefixStackPos++] = (char) ('a' + (v % 26));
			v /= 26;
			// base26 encoded prefix
			while (v) {
				prefixStack[prefixStackPos++] = (char) ('A' + (v % 26));
				v /= 26;
			}

			// test if fits
			assert(spos + prefixStackPos + 1 < SBUFMAX - 1);

			// add to notation
			while (prefixStackPos)
				sbuf[spos++] = prefixStack[--prefixStackPos];

		} else if (beenThere[id] != 0) {

			// already been there. Calculate the back-reference
			unsigned v          = nextNode - beenThere[id];

			// back-references are notated as a non-zero digit base26 prefixed by uppercase letters
			char prefixStack[16];
			int  prefixStackPos = 0;

			// base10 encoded back-reference
			prefixStack[prefixStackPos++] = (char) ('0' + (v % 10));
			v /= 10;
			// base26 encoded prefix
			while (v) {
				prefixStack[prefixStackPos++] = (char) ('A' + (v % 26));
				v /= 26;
			}

			// test if fits
			assert(spos + prefixStackPos + 1 < SBUFMAX - 1);

			// add to notation
			while (prefixStackPos)
				sbuf[spos++] = prefixStack[--prefixStackPos];

		} else {

			// call recursive encode for node
			encodeQTF(id);

		}
	}

	/**
	 * @date 2020-03-08 20:52:41
	 *
	 * Compose the notation of a given node in "placeholder/skin" notation.
	 *
	 * @param {number} id - index of node to encode
	 */
	void encodeQTF(unsigned id) {

		// extract all parts of the node
		unsigned T  = this->N[id].T;
		unsigned Ti = T & IBIT; // non-zero if result of `T` should be inverted
		unsigned Tu = T & ~IBIT; // index to `T` operand
		unsigned Q  = this->N[id].Q;
		unsigned F  = this->N[id].F;

		// assert node is invert normalised
		assert((~Q & IBIT) && (~F & IBIT));

		// decode
		if (T == 0 && F != 0) {
			// LT `"L?0:R"`
			encodeOperand(Q);
			encodeOperand(F);
			assert(spos < SBUFMAX - 1);
			sbuf[spos++] = '<';
		} else if (T == IBIT && F != 0) {
			// OR `"L?~0:R"`
			encodeOperand(Q);
			encodeOperand(F);
			assert(spos < SBUFMAX - 1);
			sbuf[spos++] = '+';
		} else if (!Ti && Tu != 0 && F == 0) {
			// AND `"L?R:0"`
			encodeOperand(Q);
			encodeOperand(Tu);
			assert(spos < SBUFMAX - 1);
			sbuf[spos++] = '&';
		} else if (Ti && Tu != 0 && F == 0) {
			// GT `"L?~R:0"`
			encodeOperand(Q);
			encodeOperand(Tu);
			assert(spos < SBUFMAX - 1);
			sbuf[spos++] = '>';
		} else if (Ti && Tu != 0 && Tu == F) {
			// XOR `"L?~R:R"`
			encodeOperand(Q);
			encodeOperand(F);
			assert(spos < SBUFMAX - 1);
			sbuf[spos++] = '^';
		} else if (Ti) {
			// QnTF `"Q?~T:F"`
			encodeOperand(Q);
			encodeOperand(Tu);
			encodeOperand(F);
			assert(spos < SBUFMAX - 1);
			sbuf[spos++] = '!';
		} else {
			// QnTF `"Q?T:F"`
			encodeOperand(Q);
			encodeOperand(Tu);
			encodeOperand(F);
			assert(spos < SBUFMAX - 1);
			sbuf[spos++] = '?';
		}

		// mark been there
		/*
		 * @date 2020-03-09 01:54:26
		 *
		 * id and nextNode will be different when the initial call is called with a different entrypoint than the root.
		 * `beenThere[]` is used to calculate back-references.
		 * `beenThere[]` points to the `nodeId` of the source `N[]`
		 * `nextNode` is value it would have when decoding the notation.
		 */
		beenThere[id] = nextNode++;
	}

	/**
	 * @date 2020-03-08 20:52:41
	 *
	 * Encode a notation describing the tree in "placeholder/skin" notation.
	 * Within the placeholders, endpoints are assigned in order of natural path which can be used as index for the skin to determine the actual endpoint.
	 *
	 * @date 2020-03-29 15:17:13
	 *
	 *  There is a known issue that `encode()` with a entrypoint other than te root might not properly order endpoints.
	 *  `"./eval 'ab+bc+a12!!' --Q --skin"`. You will find `"ca+"`
	 *
	 * @param {number} id - entrypoint
	 * @param {boolean} withPlaceholders - true for "placeholder/skin" notation
	 * @return {string} Constructed notation. State information so no multiple calls with `printf()`.
	 */
	const char *encode(unsigned id, bool withPlaceholders) {

		// special case
		if (id == 0) {
			sbuf[0] = '0';
			sbuf[1] = 0;
			return sbuf;
		}
		if (id == IBIT) {
			sbuf[0] = '0';
			sbuf[1] = '~';
			sbuf[2] = 0;
			return sbuf;
		}

		// setup state
		nextPlaceholder = withPlaceholders ? this->kstart : 0;
		nextNode        = this->nstart;
		spos            = 0;
		::memset(beenThere, 0, this->count * sizeof(beenThere[0]));
		// `skin[]` is a list sized by nextPlaceholder
		placeholdersInSync = true; // assume placeholders are in sync. Implying that no explicit skin is needed

		if (!withPlaceholders) {
			// literal endpoints
			if ((id & ~IBIT) < this->nstart) {
				// assign endpoint
				beenThere[id & ~IBIT] = id & ~IBIT;

				// encode endpoint
				encodeOperand(id & ~IBIT);
			} else {
				// encode node
				encodeQTF(id & ~IBIT);
			}
		} else {
			// placeholder/skin
			if ((id & ~IBIT) < this->nstart) {
				// 'a/<id>'
				beenThere[id & ~IBIT]   = this->kstart;
				skin[nextPlaceholder++] = id & ~IBIT;
				if ((id & ~IBIT) != this->kstart)
					placeholdersInSync = false;

				assert(spos < SBUFMAX - 1);
				sbuf[spos++] = 'a';
			} else {
				// two passes are needed because placeholders have variable length names

				// pass-1 - assign placeholders
				encodePlaceholders(id & ~IBIT);

				// erase used part of `beenThere[]`
				::memset(beenThere + this->nstart, 0, (nextNode + this->nstart) * sizeof(beenThere[0]));

				// pass-2 - encode node
				encodeQTF(id & ~IBIT);
			}
		}

		// optionally append final invert
		if (id & IBIT) {
			assert(spos < SBUFMAX - 1);
			sbuf[spos++] = '~';
		}

		// if placeholders are in sync with endpoints then skin is redundant
		if (nextPlaceholder > 0 && !placeholdersInSync) {
			// append delimiter
			assert(spos < SBUFMAX - 1);
			sbuf[spos++] = '/';

			// append contents of placeholders
			for (unsigned ph = this->kstart; ph < nextPlaceholder; ph++) {

				// endpoints are notated as a lowercase letter (`'a'` resembling KSTART) base26 prefixed by uppercase letters
				char prefixStack[16];
				int  prefixStackPos = 0;

				// zero-based copy of placeholder
				unsigned v = skin[ph] - this->kstart;

				// base26 encoded endpoint
				prefixStack[prefixStackPos++] = (char) ('a' + (v % 26));
				v /= 26;
				// base26 encoded prefix
				while (v) {
					prefixStack[prefixStackPos++] = (char) ('A' + (v % 26));
					v /= 26;
				}

				// test if fits
				assert(spos + prefixStackPos + 1 < SBUFMAX - 1);

				// add to notation
				while (prefixStackPos)
					sbuf[spos++] = prefixStack[--prefixStackPos];
			}
		}

		// append string terminator
		sbuf[spos++] = 0;

		// return encoded string
		return sbuf;
	}

	/**
	 * @date 2020-03-09 19:36:17
	 *
         * Evaluate the tree and store the result in v[]
         *
         * `this->N` contains the unified operators.
         * The parameter of this function `v` is the runtime data to which the operators should be applied.
         *
         * For each entry of `this->N[i]` and `v[i]`:
         * - the unified operator loads the operand data from `v` indicated by `Q`, `T` and `F`
         * - functionality is applied
         * - the result is stored int `v` indexed by the location of the operator
         *
         * Each data entry is a 512-bit wide vector, split into uint64_t chunks.
         * As this is a reference implementation, `SIMD` instructions should be avoided.
         *
	 * @param {vector[]} v - the evaluated result of the unified operators
	 */
	inline void eval(footprint_t *v) const {
		// for all operators eligible for evaluation...
		for (unsigned i = nstart; i < this->count; i++) {
			// point to the first chunk of the `"question"`
			const uint64_t *Q = v[this->N[i].Q].bits;
			// point to the first chunk of the `"when-true"`
			// NOTE: this can be marked as "value needs be runtime inverted"
			const uint64_t *T = v[this->N[i].T & ~IBIT].bits;
			// point to the first chunk of the `"when-false"`
			const uint64_t *F = v[this->N[i].F].bits;
			// point to the first chunk of the `"result"`
			uint64_t       *R = v[i].bits;

			// determine if the operator is `QTF` or `QnTF`
			if (this->N[i].T & IBIT) {
				// `QnTF` for each bit in the chunk, apply the operator `"Q ? !T : F"`
				for (unsigned j = 0; j < footprint_t::QUADPERFOOTPRINT; j++)
					R[j] = (Q[j] & ~T[j]) ^ (~Q[j] & F[j]);
			} else {
				// `QnTF` for each bit in the chunk, apply the operator `"Q ? T : F"`
				for (unsigned j = 0; j < footprint_t::QUADPERFOOTPRINT; j++)
					R[j] = (Q[j] & T[j]) ^ (~Q[j] & F[j]);
			}
		}
	}
};

/**
 * @date 2020-03-10 21:25:24
 *
 * Initialise test vector.
 *
 * Example expression stored in data-vector (`v[]`) and tree (`N[]`)
 *
 *    index     | v[]        |  N[]
 * -------------+------------+--------
 * [0]          | 0b00000000 | null/zero/false
 * [1=KSTART+0] | 0b10101010 | `a`
 * [2=KSTART+1] | 0b11001100 | `b`
 * [3=KSTART+2] | 0b11110000 | `c`
 * [4=NSTART+0] | 0b10001000 | `ab&`
 * [5=NSTART+1] | 0b01111000 | `ab&c^`
 *
 * Test vector inputs are in range kstart..nstart and contain all possible states on the input endpoints.
 * With 512 bit vectors this allows for 9 (`MAXSLOTS`).
 *
 * For trees with more endpoints, populate the vector with random values.
 * If you suspect that that the evaluation result is a false-positive, rerun with a different seed

 * @param {footprint_t) pFootprint - footprint to initialise
 * @param {footprint_t) kstart - kstart of tree
 * @param {footprint_t) nstart - nstart of tree
 */
void initialiseVector(footprint_t *pFootprint, unsigned kstart, unsigned nstart) {

	if (kstart == 1 && nstart <= kstart + MAXSLOTS) {

		uint64_t *v = (uint64_t *) pFootprint;

		// set 64bit slice to zero
		for (int i = 0; i < footprint_t::QUADPERFOOTPRINT * (1 + MAXSLOTS); i++)
			v[i] = 0;

		// set footprint for 64bit slice
		assert(MAXSLOTS == 9);
		for (unsigned i = 0; i < (1 << MAXSLOTS); i++) {
			// v[(i/64)+0*4] should be 0
			if (i & (1 << 0)) v[(i / 64) + 1 * footprint_t::QUADPERFOOTPRINT] |= 1LL << (i % 64);
			if (i & (1 << 1)) v[(i / 64) + 2 * footprint_t::QUADPERFOOTPRINT] |= 1LL << (i % 64);
			if (i & (1 << 2)) v[(i / 64) + 3 * footprint_t::QUADPERFOOTPRINT] |= 1LL << (i % 64);
			if (i & (1 << 3)) v[(i / 64) + 4 * footprint_t::QUADPERFOOTPRINT] |= 1LL << (i % 64);
			if (i & (1 << 4)) v[(i / 64) + 5 * footprint_t::QUADPERFOOTPRINT] |= 1LL << (i % 64);
			if (i & (1 << 5)) v[(i / 64) + 6 * footprint_t::QUADPERFOOTPRINT] |= 1LL << (i % 64);
			if (i & (1 << 6)) v[(i / 64) + 7 * footprint_t::QUADPERFOOTPRINT] |= 1LL << (i % 64);
			if (i & (1 << 7)) v[(i / 64) + 8 * footprint_t::QUADPERFOOTPRINT] |= 1LL << (i % 64);
			if (i & (1 << 8)) v[(i / 64) + 9 * footprint_t::QUADPERFOOTPRINT] |= 1LL << (i % 64);
		}

		// this might overwrite v[nstart] but that shouldn't be an issue.

	} else {
		srand(opt_seed);

		uint64_t *v = (uint64_t *) pFootprint;

		// craptastic random fill
		for (unsigned i = 0; i < footprint_t::QUADPERFOOTPRINT * nstart; i++) {
			v[i] = (uint64_t) rand();
			v[i] = (v[i] << 16) ^ (uint64_t) rand();
			v[i] = (v[i] << 16) ^ (uint64_t) rand();
			v[i] = (v[i] << 16) ^ (uint64_t) rand();
		}

		// erase v[0]
		for (int i = 0; i < footprint_t::QUADPERFOOTPRINT; i++)
			v[i] = 0;

	}
}

/**
 * Mainloop called for each program argument
 *
 * @param {string} origPattern - argument to process
 * @param {tree_t} pTree - worker tree
 * @param {footprint_t} pEval - evaluation vector
 * @return {number} 0 if something failed, otherwise crc of result
 */
unsigned mainloop(const char *origPattern, tree_t *pTree, footprint_t *pEval) {

	/*
	 * Load shrink-wrapped notation
	 */
	pTree->decode(origPattern, opt_shrinkwrap ? 1 : 0);

	/*
 	 * Extract one of the Q/T/F components
 	 */
	if (opt_Q) {
		if ((pTree->root & ~IBIT) < pTree->nstart) {
			pTree->root = 0; // treee had no nodes
		} else {
			pTree->root = pTree->N[pTree->root & ~IBIT].Q;
			// NOTE: root `IBIT` only applies to `T` and `F`
		}
	} else if (opt_T) {
		if ((pTree->root & ~IBIT) < pTree->nstart) {
			pTree->root = 0; // treee had no nodes
		} else {
			pTree->root = pTree->N[pTree->root & ~IBIT].T ^ (pTree->root & IBIT);
		}
	} else if (opt_F) {
		if ((pTree->root & ~IBIT) < pTree->nstart) {
			pTree->root = 0; // treee had no nodes
		} else {
			pTree->root = pTree->N[pTree->root & ~IBIT].F ^ (pTree->root & IBIT);
		}
	}

	/*
	 * Emit tree as code
	 */
	if (opt_code) {
		printf("({ unsigned kstart=%u, nstart=%u, _[] = {0,", pTree->kstart, pTree->nstart);

		char prefixStack[16];
		int  prefixStackPos = 0;

		/*
		 * emit endpoints
		 */
		for (unsigned i = pTree->kstart; i < pTree->nstart; i++) {
			// endpoints are notated as a lowercase letter (`'a'` resembling KSTART) base26 prefixed by uppercase letters

			// zero-based copy of endpoint
			unsigned v = i - pTree->kstart;

			// base26 encoded endpoint
			prefixStack[prefixStackPos++] = (char) ('a' + (v % 26));
			v /= 26;
			// base26 encoded prefix
			while (v) {
				prefixStack[prefixStackPos++] = (char) ('A' + (v % 26));
				v /= 26;
			}

			// add to notation
			while (prefixStackPos)
				putchar(prefixStack[--prefixStackPos]);
			// delimiter
			putchar(',');
		}

		/*
		 * Emit nodes
		 */
		for (unsigned i = pTree->nstart; i < pTree->count; i++) {
			if (pTree->N[i].T & IBIT)
				printf("  _[%u]?!_[%u]:_[%u],", pTree->N[i].Q, pTree->N[i].T ^ IBIT, pTree->N[i].F);
			else
				printf("  _[%u]? _[%u]:_[%u],", pTree->N[i].Q, pTree->N[i].T, pTree->N[i].F);
		}

		/*
		 * Emit root
		 */
		if (pTree->root & IBIT)
			printf("}; !_[%u];}) // ", pTree->root & ~IBIT);
		else
			printf("};  _[%u];}) // ", pTree->root);

		/*
		 * Emit notation
		 */

		printf("%s\n", pTree->encode(pTree->root, opt_skin ? true : false));
		return 0;
	}

	// Initialise test vector.
	initialiseVector(pEval, pTree->kstart, pTree->nstart);

#if 0
	for (unsigned j = 0; j < pTree->nstart; j++) {
		printf("%2d: ", j);
		for (int i = 0; i < QUADPERFOOTPRINT; i++)
			printf("%016lx ", evalData64[j].bits[i]);
		printf("\n");
	}
#endif

	/*
	 * Evaluate tree
	 */
	pTree->eval(pEval);

	/*
	 * Calculate crc of entry point
	 */

	unsigned crc32 = pEval[pTree->root & ~IBIT].crc32();
	// Inverted `T` is a concept not present in footprints. As a compromise, invert the result.
	if (pTree->root & IBIT)
		crc32 ^= 0xffffffff;

	/*
	 * if quiet only return crc
	 */
	if (opt_quiet)
		return crc32;

	/*
	 * Output result of test vector prefixed with sign indicating if root is inverted
	 */
	printf("%c", (pTree->root & IBIT) ? '-' : '+');
	for (int i = 0; i < footprint_t::QUADPERFOOTPRINT; i++)
		printf("%016lx ", pEval[pTree->root & ~IBIT].bits[i]);

	printf("{%08x} ", crc32);

	/*
	 * Output tree
	 */
	printf(": %26s", pTree->encode(pTree->root, opt_skin ? true : false));

	/*
	 * Output number of nodes and determine how many nodes if tree were flat
	 */
	printf(" [NUMEL=%u]", pTree->count - pTree->nstart);

	{
		// sum weights of roots
		double *weight = (double *) malloc(sizeof(double) * pTree->count);
		assert(weight);

		/*
		 * Collect data
		 */
		for (unsigned i = 0; i < pTree->nstart; i++)
			weight[i] = 0;
		for (unsigned i   = pTree->nstart; i < pTree->count; i++) {
			unsigned Q = pTree->N[i].Q;
			unsigned T = pTree->N[i].T & ~IBIT; // IBIT removed
			unsigned F = pTree->N[i].F;

			// weight = node plus weight of subtrees. Terminals count as 0
			weight[i] = 1 + weight[Q];
			if (T != Q)
				weight[i] += weight[T];
			if (F != Q && F != T)
				weight[i] += weight[F]; // xor counts once
		}

		printf(" [VCOUNT=%f]", weight[pTree->root & ~IBIT]);

		free(weight);
	}

	printf("\n");
	return (crc32 & 0xffffffff);
}

/**
 * @date 2020-03-10 21:46:10
 *
 * Perform a selftest.
 *
 * For every single-node tree there a 8 possible operands: Zero, three variables and their inverts.
 * This totals to a collection of (8*8*8) 512 trees.
 *
 * For every tree:
 *  - normalised q,t,f triplet
 *  - Save tree as string
 *  - Load tree as string
 *  - Evaluate
 *  - Compare with independent generated result
 *
 * @param {tree_t} pTree - worker tree
 * @param {footprint_t} pEval - evaluation vector
 */
void performSelfTest(tree_t *pTree, footprint_t *pEval) {

	unsigned testNr    = 0;
	unsigned numPassed = 0;

	/*
	 * Self-test prefix handling
	 */
	for (unsigned r = pTree->kstart; r < NEND; r++) {

		// load tree
		pTree->nstart = r + 1;
		pTree->count  = pTree->nstart;
		pTree->root   = r;

		// convert to prefix and back
		const char *treeName = pTree->encode(pTree->root, false);
		assert(pTree->decode(treeName, false) == 0);

		if (pTree->root != r) {
			fprintf(stderr, "prefix fail: expected=%u encountered=%u %s\n", r, pTree->root, treeName);
			exit(1);
		}
	}

	/*
	 * self-test with different program settings
	 */
	// @formatter:off
	for (unsigned iFast=0; iFast<2; iFast++) // decode notation in fast mode
	for (unsigned iSkin=0; iSkin<2; iSkin++) // use placeholder/skin notation
	for (unsigned iPure=0; iPure<2; iPure++) { // force rewriting
	// @formatter:on

		/*
		 * Test all 512 operand combinations. Zero, 3 endpoints and their 4 inverts (8*8*8=512)
		 */

		// @formatter:off
		for (unsigned Fo = 0; Fo < pTree->kstart + 3; Fo++) // operand of F: 0, a, b, c
		for (unsigned Fi = 0; Fi < 2; Fi++)          // inverting of F
		for (unsigned To = 0; To < pTree->kstart + 3; To++)
		for (unsigned Ti = 0; Ti < 2; Ti++)
		for (unsigned Qo = 0; Qo < pTree->kstart + 3; Qo++)
		for (unsigned Qi = 0; Qi < 2; Qi++) {
		// @formatter:on

			// additional rangecheck
			if (Qo && Qo < pTree->kstart) continue;
			if (To && To < pTree->kstart) continue;
			if (Fo && Fo < pTree->kstart) continue;

			// bump test number
			testNr++;

			/*
			 * Load the tree
			 */

			opt_fast = iFast; // decode fast or safe
			opt_pure = iPure; // expand `QTF->QnTF` rewriting

			pTree->nstart = pTree->kstart + 3;
			pTree->count  = pTree->nstart;
			pTree->root   = pTree->addNode(Qo ^ (Qi ? IBIT : 0), To ^ (Ti ? IBIT : 0), Fo ^ (Fi ? IBIT : 0));

			/*
			 * save with placeholders and reload
			 */
			const char *treeName = pTree->encode(pTree->root, iSkin ? true : false);
			assert(pTree->decode(treeName, false) == 0);

			/*
			 * Evaluate tree
			 */

			// load test vector
			pEval[0].bits[0]                 = 0b00000000; // v[0]
			pEval[pTree->kstart + 0].bits[0] = 0b10101010; // v[1]
			pEval[pTree->kstart + 1].bits[0] = 0b11001100; // v[2]
			pEval[pTree->kstart + 2].bits[0] = 0b11110000; // v[3]

			// evaluate
			pTree->eval(pEval);

			/*
			 * The footprint contains the tree outcome for every possible value combination the endpoints can have
			 * Loop through every state and verify the foorptint is correct
			 */
			// @formatter:off
			for (unsigned c = 0; c < 2; c++)
			for (unsigned b = 0; b < 2; b++)
			for (unsigned a = 0; a < 2; a++) {
			// @formatter:on

				// bump test number
				testNr++;

				unsigned q, t, f;

				assert(pTree->kstart == KSTART); // for switch/case values

				/*
				 * Substitute endpoints `a-c` with their actual values.
				 */
				// @formatter:off
				switch (Qo) {
				case 0:            q = 0; break;
				case (KSTART + 0): q = a; break;
				case (KSTART + 1): q = b; break;
				case (KSTART + 2): q = c; break;
				}
				if (Qi) q ^= 1;

				switch (To) {
				case 0:            t = 0; break;
				case (KSTART + 0): t = a; break;
				case (KSTART + 1): t = b; break;
				case (KSTART + 2): t = c; break;
				}
				if (Ti) t ^= 1;

				switch (Fo) {
				case 0:            f = 0; break;
				case (KSTART + 0): f = a; break;
				case (KSTART + 1): f = b; break;
				case (KSTART + 2): f = c; break;
				}
				if (Fi) f ^= 1;
				// @formatter:on

				/*
				 * `normaliseNode()` creates a tree with the expression `Q?T:F"`
				 * Calculate the outcome without using the tree.
				 */
				unsigned expected = q ? t : f;

				// extract encountered from footprint.
				unsigned ix          = c << 2 | b << 1 | a;
				unsigned encountered = pEval[pTree->root & ~IBIT].bits[0] & (1 << ix) ? 1 : 0;
				if (pTree->root & IBIT)
					encountered ^= 1; // invert result

				if (expected != encountered) {
					fprintf(stderr, "fail: testNr=%u iFast=%u iPure=%u iSkin=%u expected=%08x encountered:%08x Q=%c%x T=%c%x F=%c%x q=%x t=%x f=%x c=%x b=%x a=%x tree=%s\n",
						testNr, iFast, iPure, iSkin, expected, encountered, Qi ? '~' : ' ', Qo, Ti ? '~' : ' ', To, Fi ? '~' : ' ', Fo, q, t, f, c, b, a, treeName);
					exit(1);
				}
				numPassed++;
			}
		}
	}

	fprintf(stderr, "%s() passed %u tests\n", __FUNCTION__, numPassed);
}

/**
 * @date 2020-03-06 20:22:23
 *
 * Program main entry point
 *
 * @param  {number} argc - number of arguments
 * @param  {string[]} argv - program arguments
 * @return {number} 0 on normal return, non-zero when attention is required
 */
int main(int argc, char *argv[]) {
	setlinebuf(stdout);

	// create an empty tree
	tree_t      *pTree       = new tree_t(KSTART, KSTART);
	// create an evaluation vector
	footprint_t *pFootprints = new footprint_t[NEND];

	/*
	 *  Process program options
	 */
	for (;;) {
		// Long option shortcuts
		enum {
			// long-only opts
			LO_FAST    = 1,
			LO_PURE,
			LO_SEED,
			LO_SELFTEST,
			LO_SHRINKWRAP,
			// short opts
			LO_CODE    = 'c',
			LO_F       = 'F',
			LO_HELP    = 'h',
			LO_Q       = 'Q',
			LO_QUIET   = 'q',
			LO_SKIN    = 's',
			LO_T       = 'T',
			LO_VERBOSE = 'v',
		};

		// long option descriptions
		static struct option long_options[] = {
			/* name, has_arg, flag, val */
			{"code",       0, 0, LO_CODE},
			{"help",       0, 0, LO_HELP},
			{"pure",       0, 0, LO_PURE},
			{"quiet",      0, 0, LO_QUIET},
			{"fast",       0, 0, LO_FAST},
			{"seed",       1, 0, LO_SEED},
			{"selftest",   0, 0, LO_SELFTEST},
			{"shrinkwrap", 0, 0, LO_SHRINKWRAP},
			{"skin",       0, 0, LO_SKIN},
			{"verbose",    0, 0, LO_VERBOSE},
			{"Q",          0, 0, LO_Q},
			{"T",          0, 0, LO_T},
			{"F",          0, 0, LO_F},
			//
			{NULL,         0, 0, 0}
		};

		char optstring[64];
		char *cp          = optstring;
		int  option_index = 0;

		/* construct optarg */
		for (int i = 0; long_options[i].name; i++) {
			if (isalpha(long_options[i].val)) {
				*cp++ = (char) long_options[i].val;

				if (long_options[i].has_arg != 0)
					*cp++ = ':';
				if (long_options[i].has_arg == 2)
					*cp++ = ':';
			}
		}

		*cp = '\0';

		// parse long options
		int c = getopt_long(argc, argv, optstring, long_options, &option_index);
		if (c == -1)
			break;

		switch (c) {
		case LO_CODE:
			opt_code++;
			break;
		case LO_F:
			opt_F++;
			break;
		case LO_FAST:
			opt_fast++;
			break;
		case LO_HELP:
			usage(argv, true);
			exit(0);
		case LO_Q:
			opt_Q++;
			break;
		case LO_PURE:
			opt_pure++;
			break;
		case LO_QUIET:
			opt_quiet++;
			break;
		case LO_SEED:
			opt_seed = ::strtoul(optarg, NULL, 0);
			break;
		case LO_SELFTEST:
			performSelfTest(pTree, pFootprints);
			exit(0);
			break;
		case LO_SHRINKWRAP:
			opt_shrinkwrap++;
			break;
		case LO_SKIN:
			opt_skin++;
			break;
		case LO_T:
			opt_T++;
			break;
		case LO_VERBOSE:
			opt_verbose++;
			break;
		case '?':
			fprintf(stderr, "Try `%s --help' for more information.\n", argv[0]);
			exit(1);
		default:
			fprintf(stderr, "getopt_long() returned character code %d\n", c);
			exit(1);
		}
	}

	// At least one program argument
	if (argc - optind < 1) {
		usage(argv, false);
		exit(1);
	}

	// storage for testing difference between arguments
	unsigned crc32;
	bool     differ          = false;

	for (int iArg = optind; iArg < argc; iArg++) {
		const char *pName = argv[iArg];

		if (pName[0] != '-' || pName[1] != 0) {
			// read from arg
			if (iArg == optind)
				crc32 = mainloop(pName, pTree, pFootprints);
			else
				differ |= (crc32 != mainloop(pName, pTree, pFootprints));
		} else {
			// read from stdin
			char   *pBuffer = (char *) malloc(10000000);
			size_t rval     = fread(pBuffer, 1, 10000000, stdin);
			if (rval == 10000000) {
				fprintf(stderr, "stdin too long\n");
				exit(1);
			}
			pBuffer[rval] = 0;
			mainloop(pBuffer, pTree, pFootprints);
			free(pBuffer);
		}

	}

	// compare crc is multiple patterns given
	if (argc - optind > 1) {
		if (differ) {
			fprintf(stderr, "crc DIFFER\n");
			exit(1);
		} else if (!opt_quiet) {
			fprintf(stderr, "crc same\n");
		}
	}

	return 0;
}
